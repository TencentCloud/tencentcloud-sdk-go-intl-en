// Copyright (c) 2017-2025 Tencent. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package v20180801

import (
    tcerr "github.com/tencentcloud/tencentcloud-sdk-go-intl-en/tencentcloud/common/errors"
    tchttp "github.com/tencentcloud/tencentcloud-sdk-go-intl-en/tencentcloud/common/http"
    "github.com/tencentcloud/tencentcloud-sdk-go-intl-en/tencentcloud/common/json"
)

// Predefined struct for user
type AddDelayLiveStreamRequestParams struct {
	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Delay time in seconds, up to 600s.
	DelayTime *uint64 `json:"DelayTime,omitnil,omitempty" name:"DelayTime"`

	// Expiration time of the configured delayed playback in UTC format, such as 2018-11-29T19:00:00Z.
	// Notes:
	// 1. The configuration will expire after 7 days by default and can last up to 7 days.
	// 2. The Beijing time is in UTC+8. This value should be in the format as required by ISO 8601. For more information, please see [ISO Date and Time Format](https://intl.cloud.tencent.com/document/product/266/11732?from_cn_redirect=1#iso-.E6.97.A5.E6.9C.9F.E6.A0.BC.E5.BC.8F).
	ExpireTime *string `json:"ExpireTime,omitnil,omitempty" name:"ExpireTime"`
}

type AddDelayLiveStreamRequest struct {
	*tchttp.BaseRequest
	
	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Delay time in seconds, up to 600s.
	DelayTime *uint64 `json:"DelayTime,omitnil,omitempty" name:"DelayTime"`

	// Expiration time of the configured delayed playback in UTC format, such as 2018-11-29T19:00:00Z.
	// Notes:
	// 1. The configuration will expire after 7 days by default and can last up to 7 days.
	// 2. The Beijing time is in UTC+8. This value should be in the format as required by ISO 8601. For more information, please see [ISO Date and Time Format](https://intl.cloud.tencent.com/document/product/266/11732?from_cn_redirect=1#iso-.E6.97.A5.E6.9C.9F.E6.A0.BC.E5.BC.8F).
	ExpireTime *string `json:"ExpireTime,omitnil,omitempty" name:"ExpireTime"`
}

func (r *AddDelayLiveStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AddDelayLiveStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "AppName")
	delete(f, "DomainName")
	delete(f, "StreamName")
	delete(f, "DelayTime")
	delete(f, "ExpireTime")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "AddDelayLiveStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type AddDelayLiveStreamResponseParams struct {
	// The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type AddDelayLiveStreamResponse struct {
	*tchttp.BaseResponse
	Response *AddDelayLiveStreamResponseParams `json:"Response"`
}

func (r *AddDelayLiveStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AddDelayLiveStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type AddLiveDomainRequestParams struct {
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Domain name type.
	// 0: push domain name.
	// 1: playback domain name.
	DomainType *uint64 `json:"DomainType,omitnil,omitempty" name:"DomainType"`

	// Pull domain name type:
	// 1: Mainland China.
	// 2: global.
	// 3: outside Mainland China.
	// Default value: 1.
	PlayType *uint64 `json:"PlayType,omitnil,omitempty" name:"PlayType"`

	// Whether it is LCB:
	// 0: LVB,
	// 1: LCB.
	// Default value: 0.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// Whether it is LVB on Mini Program.
	// 0: LVB.
	// 1: LVB on Mini Program.
	// Default value: 0.
	IsMiniProgramLive *int64 `json:"IsMiniProgramLive,omitnil,omitempty" name:"IsMiniProgramLive"`

	// The domain verification type.
	// Valid values (the value of this parameter must be the same as `VerifyType` of the `AuthenticateDomainOwner` API):
	// dnsCheck: Check immediately whether the verification DNS record has been added successfully. If so, record this verification result.
	// fileCheck: Check immediately whether the verification HTML file has been uploaded successfully. If so, record this verification result.
	// dbCheck: Check whether the domain has already been verified.
	// If you do not pass a value, `dbCheck` will be used.
	VerifyOwnerType *string `json:"VerifyOwnerType,omitnil,omitempty" name:"VerifyOwnerType"`
}

type AddLiveDomainRequest struct {
	*tchttp.BaseRequest
	
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Domain name type.
	// 0: push domain name.
	// 1: playback domain name.
	DomainType *uint64 `json:"DomainType,omitnil,omitempty" name:"DomainType"`

	// Pull domain name type:
	// 1: Mainland China.
	// 2: global.
	// 3: outside Mainland China.
	// Default value: 1.
	PlayType *uint64 `json:"PlayType,omitnil,omitempty" name:"PlayType"`

	// Whether it is LCB:
	// 0: LVB,
	// 1: LCB.
	// Default value: 0.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// Whether it is LVB on Mini Program.
	// 0: LVB.
	// 1: LVB on Mini Program.
	// Default value: 0.
	IsMiniProgramLive *int64 `json:"IsMiniProgramLive,omitnil,omitempty" name:"IsMiniProgramLive"`

	// The domain verification type.
	// Valid values (the value of this parameter must be the same as `VerifyType` of the `AuthenticateDomainOwner` API):
	// dnsCheck: Check immediately whether the verification DNS record has been added successfully. If so, record this verification result.
	// fileCheck: Check immediately whether the verification HTML file has been uploaded successfully. If so, record this verification result.
	// dbCheck: Check whether the domain has already been verified.
	// If you do not pass a value, `dbCheck` will be used.
	VerifyOwnerType *string `json:"VerifyOwnerType,omitnil,omitempty" name:"VerifyOwnerType"`
}

func (r *AddLiveDomainRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AddLiveDomainRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "DomainType")
	delete(f, "PlayType")
	delete(f, "IsDelayLive")
	delete(f, "IsMiniProgramLive")
	delete(f, "VerifyOwnerType")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "AddLiveDomainRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type AddLiveDomainResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type AddLiveDomainResponse struct {
	*tchttp.BaseResponse
	Response *AddLiveDomainResponseParams `json:"Response"`
}

func (r *AddLiveDomainResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AddLiveDomainResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type AddLiveWatermarkRequestParams struct {
	// Watermark image URL.
	// Unallowed characters in the URL:
	//  ;(){}$>`#"\'|
	PictureUrl *string `json:"PictureUrl,omitnil,omitempty" name:"PictureUrl"`

	// Watermark name.
	// Up to 16 bytes.
	WatermarkName *string `json:"WatermarkName,omitnil,omitempty" name:"WatermarkName"`

	// Display position: X-axis offset in %. Default value: 0.
	XPosition *int64 `json:"XPosition,omitnil,omitempty" name:"XPosition"`

	// Display position: Y-axis offset in %. Default value: 0.
	YPosition *int64 `json:"YPosition,omitnil,omitempty" name:"YPosition"`

	// Watermark width or its percentage of the live streaming video width. It is recommended to just specify either height or width as the other will be scaled proportionally to avoid distortions. The original width is used by default.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Watermark height, which is set by entering a percentage of the live stream image’s original height. You are advised to set either the height or width as the other will be scaled proportionally to avoid distortions. Default value: original height.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`
}

type AddLiveWatermarkRequest struct {
	*tchttp.BaseRequest
	
	// Watermark image URL.
	// Unallowed characters in the URL:
	//  ;(){}$>`#"\'|
	PictureUrl *string `json:"PictureUrl,omitnil,omitempty" name:"PictureUrl"`

	// Watermark name.
	// Up to 16 bytes.
	WatermarkName *string `json:"WatermarkName,omitnil,omitempty" name:"WatermarkName"`

	// Display position: X-axis offset in %. Default value: 0.
	XPosition *int64 `json:"XPosition,omitnil,omitempty" name:"XPosition"`

	// Display position: Y-axis offset in %. Default value: 0.
	YPosition *int64 `json:"YPosition,omitnil,omitempty" name:"YPosition"`

	// Watermark width or its percentage of the live streaming video width. It is recommended to just specify either height or width as the other will be scaled proportionally to avoid distortions. The original width is used by default.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Watermark height, which is set by entering a percentage of the live stream image’s original height. You are advised to set either the height or width as the other will be scaled proportionally to avoid distortions. Default value: original height.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`
}

func (r *AddLiveWatermarkRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AddLiveWatermarkRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "PictureUrl")
	delete(f, "WatermarkName")
	delete(f, "XPosition")
	delete(f, "YPosition")
	delete(f, "Width")
	delete(f, "Height")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "AddLiveWatermarkRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type AddLiveWatermarkResponseParams struct {
	// Watermark ID.
	WatermarkId *uint64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type AddLiveWatermarkResponse struct {
	*tchttp.BaseResponse
	Response *AddLiveWatermarkResponseParams `json:"Response"`
}

func (r *AddLiveWatermarkResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AddLiveWatermarkResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type AuthenticateDomainOwnerRequestParams struct {
	// The domain to verify.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The verification type. Valid values:
	// dnsCheck: Check immediately whether the verification DNS record has been added successfully. If so, record this verification result.
	// fileCheck: Check immediately whether the verification HTML file has been uploaded successfully. If so, record this verification result.
	// dbCheck: Check whether the domain has already been successfully verified.
	VerifyType *string `json:"VerifyType,omitnil,omitempty" name:"VerifyType"`
}

type AuthenticateDomainOwnerRequest struct {
	*tchttp.BaseRequest
	
	// The domain to verify.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The verification type. Valid values:
	// dnsCheck: Check immediately whether the verification DNS record has been added successfully. If so, record this verification result.
	// fileCheck: Check immediately whether the verification HTML file has been uploaded successfully. If so, record this verification result.
	// dbCheck: Check whether the domain has already been successfully verified.
	VerifyType *string `json:"VerifyType,omitnil,omitempty" name:"VerifyType"`
}

func (r *AuthenticateDomainOwnerRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AuthenticateDomainOwnerRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "VerifyType")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "AuthenticateDomainOwnerRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type AuthenticateDomainOwnerResponseParams struct {
	// The content verified.
	// If `VerifyType` is `dnsCheck`, this is the TXT record that should be added for verification.
	// If `VerifyType` is `fileCheck`, this is the file that should be uploaded for verification.
	Content *string `json:"Content,omitnil,omitempty" name:"Content"`

	// The verification status.
	// If the value of this parameter is 0 or greater, the domain has been verified.
	// If the value of this parameter is smaller than 0, the domain has not been verified.
	Status *int64 `json:"Status,omitnil,omitempty" name:"Status"`

	// The primary domain of the domain verified.
	// Verification is not required if another domain under the same primary domain has been successfully verified.
	MainDomain *string `json:"MainDomain,omitnil,omitempty" name:"MainDomain"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type AuthenticateDomainOwnerResponse struct {
	*tchttp.BaseResponse
	Response *AuthenticateDomainOwnerResponseParams `json:"Response"`
}

func (r *AuthenticateDomainOwnerResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *AuthenticateDomainOwnerResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type BandwidthInfo struct {
	// Format of return value:
	// yyyy-mm-dd HH:MM:SS
	// The time accuracy matches with the query granularity.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Bandwidth.
	Bandwidth *float64 `json:"Bandwidth,omitnil,omitempty" name:"Bandwidth"`
}

type BatchDomainOperateErrors struct {
	// The domain that the API failed to operate.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The API 3.0 error code.
	Code *string `json:"Code,omitnil,omitempty" name:"Code"`

	// The API 3.0 error message.
	Message *string `json:"Message,omitnil,omitempty" name:"Message"`
}

type BillDataInfo struct {
	// Time point in the format of `yyyy-mm-dd HH:MM:SS`.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Bandwidth in Mbps.
	Bandwidth *float64 `json:"Bandwidth,omitnil,omitempty" name:"Bandwidth"`

	// Traffic in MB.
	Flux *float64 `json:"Flux,omitnil,omitempty" name:"Flux"`

	// Time point of peak value in the format of `yyyy-mm-dd HH:MM:SS`. As raw data is at a 5-minute granularity, if data at a 1-hour or 1-day granularity is queried, the time point of peak bandwidth value at the corresponding granularity will be returned.
	PeakTime *string `json:"PeakTime,omitnil,omitempty" name:"PeakTime"`
}

type CallBackRuleInfo struct {
	// The rule creation time.
	// Note: Beijing time (UTC+8) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// The rule update time.
	// Note: Beijing time (UTC+8) is used.
	UpdateTime *string `json:"UpdateTime,omitnil,omitempty" name:"UpdateTime"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`
}

type CallBackTemplateInfo struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Stream starting callback URL.
	StreamBeginNotifyUrl *string `json:"StreamBeginNotifyUrl,omitnil,omitempty" name:"StreamBeginNotifyUrl"`

	// Stream mixing callback URL (disused)
	StreamMixNotifyUrl *string `json:"StreamMixNotifyUrl,omitnil,omitempty" name:"StreamMixNotifyUrl"`

	// Interruption callback URL.
	StreamEndNotifyUrl *string `json:"StreamEndNotifyUrl,omitnil,omitempty" name:"StreamEndNotifyUrl"`

	// Recording callback URL.
	RecordNotifyUrl *string `json:"RecordNotifyUrl,omitnil,omitempty" name:"RecordNotifyUrl"`

	// Screencapturing callback URL.
	SnapshotNotifyUrl *string `json:"SnapshotNotifyUrl,omitnil,omitempty" name:"SnapshotNotifyUrl"`

	// Porn detection callback URL.
	PornCensorshipNotifyUrl *string `json:"PornCensorshipNotifyUrl,omitnil,omitempty" name:"PornCensorshipNotifyUrl"`

	// Callback authentication key.
	CallbackKey *string `json:"CallbackKey,omitnil,omitempty" name:"CallbackKey"`

	// The push error callback URL.
	// Note: This field may return null, indicating that no valid values can be obtained.
	PushExceptionNotifyUrl *string `json:"PushExceptionNotifyUrl,omitnil,omitempty" name:"PushExceptionNotifyUrl"`

	// The audio/video moderation callback URL.
	// Note: This field may return null, indicating that no valid values can be obtained.
	AudioAuditNotifyUrl *string `json:"AudioAuditNotifyUrl,omitnil,omitempty" name:"AudioAuditNotifyUrl"`
}

// Predefined struct for user
type CancelCommonMixStreamRequestParams struct {
	// ID of stream mix session (from applying for stream mix to canceling stream mix).
	// This value is the same as the `MixStreamSessionId` in `CreateCommonMixStream`.
	MixStreamSessionId *string `json:"MixStreamSessionId,omitnil,omitempty" name:"MixStreamSessionId"`
}

type CancelCommonMixStreamRequest struct {
	*tchttp.BaseRequest
	
	// ID of stream mix session (from applying for stream mix to canceling stream mix).
	// This value is the same as the `MixStreamSessionId` in `CreateCommonMixStream`.
	MixStreamSessionId *string `json:"MixStreamSessionId,omitnil,omitempty" name:"MixStreamSessionId"`
}

func (r *CancelCommonMixStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CancelCommonMixStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "MixStreamSessionId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CancelCommonMixStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CancelCommonMixStreamResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CancelCommonMixStreamResponse struct {
	*tchttp.BaseResponse
	Response *CancelCommonMixStreamResponseParams `json:"Response"`
}

func (r *CancelCommonMixStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CancelCommonMixStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type CdnPlayStatData struct {
	// Time point in the format of `yyyy-mm-dd HH:MM:SS`.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Bandwidth in Mbps.
	Bandwidth *float64 `json:"Bandwidth,omitnil,omitempty" name:"Bandwidth"`

	// Traffic in MB.
	Flux *float64 `json:"Flux,omitnil,omitempty" name:"Flux"`

	// Number of new requests.
	Request *uint64 `json:"Request,omitnil,omitempty" name:"Request"`

	// Number of concurrent connections.
	Online *uint64 `json:"Online,omitnil,omitempty" name:"Online"`
}

type CertInfo struct {
	// Certificate ID.
	CertId *int64 `json:"CertId,omitnil,omitempty" name:"CertId"`

	// Certificate name.
	CertName *string `json:"CertName,omitnil,omitempty" name:"CertName"`

	// Description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// The creation time in UTC format.
	// Note: Beijing time (UTC+8) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// Certificate content.
	HttpsCrt *string `json:"HttpsCrt,omitnil,omitempty" name:"HttpsCrt"`

	// Certificate type.
	// 0: user-added certificate
	// 1: Tencent Cloud-hosted certificate
	CertType *int64 `json:"CertType,omitnil,omitempty" name:"CertType"`

	// The certificate expiration time in UTC format.
	// Note: Beijing time (UTC+8) is used.
	CertExpireTime *string `json:"CertExpireTime,omitnil,omitempty" name:"CertExpireTime"`

	// List of domain names that use this certificate.
	DomainList []*string `json:"DomainList,omitnil,omitempty" name:"DomainList"`
}

type ClientIpPlaySumInfo struct {
	// Client IP in dotted-decimal notation.
	ClientIp *string `json:"ClientIp,omitnil,omitempty" name:"ClientIp"`

	// District where the client is located.
	Province *string `json:"Province,omitnil,omitempty" name:"Province"`

	// Total traffic.
	TotalFlux *float64 `json:"TotalFlux,omitnil,omitempty" name:"TotalFlux"`

	// Total number of requests.
	TotalRequest *uint64 `json:"TotalRequest,omitnil,omitempty" name:"TotalRequest"`

	// Total number of failed requests.
	TotalFailedRequest *uint64 `json:"TotalFailedRequest,omitnil,omitempty" name:"TotalFailedRequest"`

	// Country/region where the client is located.
	CountryArea *string `json:"CountryArea,omitnil,omitempty" name:"CountryArea"`
}

type CommonMixControlParams struct {
	// Value range: [0,1]. 
	// If 1 is entered, when the layer resolution in the parameter is different from the actual video resolution, the video will be automatically cropped according to the resolution set by the layer.
	UseMixCropCenter *int64 `json:"UseMixCropCenter,omitnil,omitempty" name:"UseMixCropCenter"`

	// Value range: [0,1].
	// If this parameter is set to 1, when both `InputStreamList` and `OutputParams.OutputStreamType` are set to 1, you can copy a stream instead of canceling it.
	AllowCopy *int64 `json:"AllowCopy,omitnil,omitempty" name:"AllowCopy"`

	// Valid values: 0, 1
	// If you set this parameter to 1, SEI (Supplemental Enhanced Information) of the input streams will be passed through.
	PassInputSei *int64 `json:"PassInputSei,omitnil,omitempty" name:"PassInputSei"`
}

type CommonMixCropParams struct {
	// Crop width. Value range: [0,2000].
	CropWidth *float64 `json:"CropWidth,omitnil,omitempty" name:"CropWidth"`

	// Crop height. Value range: [0,2000].
	CropHeight *float64 `json:"CropHeight,omitnil,omitempty" name:"CropHeight"`

	// Starting crop X coordinate. Value range: [0,2000].
	CropStartLocationX *float64 `json:"CropStartLocationX,omitnil,omitempty" name:"CropStartLocationX"`

	// Starting crop Y coordinate. Value range: [0,2000].
	CropStartLocationY *float64 `json:"CropStartLocationY,omitnil,omitempty" name:"CropStartLocationY"`
}

type CommonMixInputParam struct {
	// Input stream name, which can contain up to 80 bytes of letters, digits, and underscores.
	// The value should be the name of an input stream for stream mix when `LayoutParams.InputType` is set to `0` (audio and video), `4` (pure audio), or `5` (pure video).
	// The value can be a random name for identification, such as `Canvas1` or `Picture1`, when `LayoutParams.InputType` is set to `2` (image) or `3` (canvas).
	InputStreamName *string `json:"InputStreamName,omitnil,omitempty" name:"InputStreamName"`

	// Input stream layout parameter.
	LayoutParams *CommonMixLayoutParams `json:"LayoutParams,omitnil,omitempty" name:"LayoutParams"`

	// Input stream crop parameter.
	CropParams *CommonMixCropParams `json:"CropParams,omitnil,omitempty" name:"CropParams"`
}

type CommonMixLayoutParams struct {
	// Input layer. Value range: [1,16]
	// (1) For the background stream, i.e., the room owner’s image or the canvas, set this parameter to `1`.
	// (2) This parameter is required for audio-only stream mixing as well.
	// Note that two inputs cannot have the same `ImageLayer` value.
	ImageLayer *int64 `json:"ImageLayer,omitnil,omitempty" name:"ImageLayer"`

	// Input type. Value range: [0,5].
	// If this parameter is left empty, 0 will be used by default.
	// 0: the input stream is audio/video.
	// 2: the input stream is image.
	// 3: the input stream is canvas. 
	// 4: the input stream is audio.
	// 5: the input stream is pure video.
	InputType *int64 `json:"InputType,omitnil,omitempty" name:"InputType"`

	// Output height of input video image. Value range:
	// Pixel: [0,2000]
	// Percentage: [0.01,0.99]
	// If this parameter is left empty, the input stream height will be used by default.
	// If percentage is used, the expected output is (percentage * background height).
	ImageHeight *float64 `json:"ImageHeight,omitnil,omitempty" name:"ImageHeight"`

	// Output width of input video image. Value range:
	// Pixel: [0,2000]
	// Percentage: [0.01,0.99]
	// If this parameter is left empty, the input stream width will be used by default.
	// If percentage is used, the expected output is (percentage * background width).
	ImageWidth *float64 `json:"ImageWidth,omitnil,omitempty" name:"ImageWidth"`

	// X-axis offset of input in output video image. Value range:
	// Pixel: [0,2000]
	// Percentage: [0.01,0.99]
	// If this parameter is left empty, 0 will be used by default.
	// Horizontal offset from the top-left corner of main host background video image. 
	// If percentage is used, the expected output is (percentage * background width).
	LocationX *float64 `json:"LocationX,omitnil,omitempty" name:"LocationX"`

	// Y-axis offset of input in output video image. Value range:
	// Pixel: [0,2000]
	// Percentage: [0.01,0.99]
	// If this parameter is left empty, 0 will be used by default.
	// Vertical offset from the top-left corner of main host background video image. 
	// If percentage is used, the expected output is (percentage * background width)
	LocationY *float64 `json:"LocationY,omitnil,omitempty" name:"LocationY"`

	// When `InputType` is 3 (canvas), this value indicates the canvas color.
	// Commonly used colors include:
	// Red: 0xcc0033.
	// Yellow: 0xcc9900.
	// Green: 0xcccc33.
	// Blue: 0x99CCFF.
	// Black: 0x000000.
	// White: 0xFFFFFF.
	// Gray: 0x999999
	Color *string `json:"Color,omitnil,omitempty" name:"Color"`

	// When `InputType` is 2 (image), this value is the watermark ID.
	WatermarkId *int64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`
}

type CommonMixOutputParams struct {
	// Output stream name.
	OutputStreamName *string `json:"OutputStreamName,omitnil,omitempty" name:"OutputStreamName"`

	// Output stream type. Valid values: [0,1].
	// If this parameter is left empty, 0 will be used by default.
	// If the output stream is a stream in the input stream list, enter 0.
	// If you want the stream mix result to be a new stream, enter 1.
	// If this value is 1, `output_stream_id` cannot appear in `input_stram_list`, and there cannot be a stream with the same ID on the LVB backend.
	OutputStreamType *int64 `json:"OutputStreamType,omitnil,omitempty" name:"OutputStreamType"`

	// The output bitrate. Value range: 1-10000.
	// If you do not specify this, the system will select a bitrate automatically.
	OutputStreamBitRate *int64 `json:"OutputStreamBitRate,omitnil,omitempty" name:"OutputStreamBitRate"`

	// Output stream GOP size. Value range: [1,10].
	// If this parameter is left empty, the system will automatically determine.
	OutputStreamGop *int64 `json:"OutputStreamGop,omitnil,omitempty" name:"OutputStreamGop"`

	// Output stream frame rate. Value range: [1,60].
	// If this parameter is left empty, the system will automatically determine.
	OutputStreamFrameRate *int64 `json:"OutputStreamFrameRate,omitnil,omitempty" name:"OutputStreamFrameRate"`

	// Output stream audio bitrate. Value range: [1,500]
	// If this parameter is left empty, the system will automatically determine.
	OutputAudioBitRate *int64 `json:"OutputAudioBitRate,omitnil,omitempty" name:"OutputAudioBitRate"`

	// Output stream audio sample rate. Valid values: [96000, 88200, 64000, 48000, 44100, 32000,24000, 22050, 16000, 12000, 11025, 8000].
	// If this parameter is left empty, the system will automatically determine.
	OutputAudioSampleRate *int64 `json:"OutputAudioSampleRate,omitnil,omitempty" name:"OutputAudioSampleRate"`

	// Output stream audio sound channel. Valid values: [1,2].
	// If this parameter is left empty, the system will automatically determine.
	OutputAudioChannels *int64 `json:"OutputAudioChannels,omitnil,omitempty" name:"OutputAudioChannels"`

	// SEI information in output stream. If there are no special needs, leave it empty.
	MixSei *string `json:"MixSei,omitnil,omitempty" name:"MixSei"`
}

type ConcurrentRecordStreamNum struct {
	// Time point.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Number of channels.
	Num *uint64 `json:"Num,omitnil,omitempty" name:"Num"`
}

// Predefined struct for user
type CreateCommonMixStreamRequestParams struct {
	// ID of a stream mix session (from applying for the stream mix to cancelling it). This parameter can contain up to 80 bytes of letters, digits, and underscores.
	MixStreamSessionId *string `json:"MixStreamSessionId,omitnil,omitempty" name:"MixStreamSessionId"`

	// Input stream list for stream mix.
	InputStreamList []*CommonMixInputParam `json:"InputStreamList,omitnil,omitempty" name:"InputStreamList"`

	// Output stream parameter for stream mix.
	OutputParams *CommonMixOutputParams `json:"OutputParams,omitnil,omitempty" name:"OutputParams"`

	// Input template ID. If this parameter is set, the output will be generated according to the default template layout, and there is no need to enter the custom position parameters.
	// If this parameter is left empty, 0 will be used by default.
	// For two input sources, 10, 20, 30, 40, and 50 are supported.
	// For three input sources, 310, 390, and 391 are supported.
	// For four input sources, 410 is supported.
	// For five input sources, 510 and 590 are supported.
	// For six input sources, 610 is supported.
	MixStreamTemplateId *int64 `json:"MixStreamTemplateId,omitnil,omitempty" name:"MixStreamTemplateId"`

	// Special control parameter for stream mix. If there are no special needs, leave it empty.
	ControlParams *CommonMixControlParams `json:"ControlParams,omitnil,omitempty" name:"ControlParams"`
}

type CreateCommonMixStreamRequest struct {
	*tchttp.BaseRequest
	
	// ID of a stream mix session (from applying for the stream mix to cancelling it). This parameter can contain up to 80 bytes of letters, digits, and underscores.
	MixStreamSessionId *string `json:"MixStreamSessionId,omitnil,omitempty" name:"MixStreamSessionId"`

	// Input stream list for stream mix.
	InputStreamList []*CommonMixInputParam `json:"InputStreamList,omitnil,omitempty" name:"InputStreamList"`

	// Output stream parameter for stream mix.
	OutputParams *CommonMixOutputParams `json:"OutputParams,omitnil,omitempty" name:"OutputParams"`

	// Input template ID. If this parameter is set, the output will be generated according to the default template layout, and there is no need to enter the custom position parameters.
	// If this parameter is left empty, 0 will be used by default.
	// For two input sources, 10, 20, 30, 40, and 50 are supported.
	// For three input sources, 310, 390, and 391 are supported.
	// For four input sources, 410 is supported.
	// For five input sources, 510 and 590 are supported.
	// For six input sources, 610 is supported.
	MixStreamTemplateId *int64 `json:"MixStreamTemplateId,omitnil,omitempty" name:"MixStreamTemplateId"`

	// Special control parameter for stream mix. If there are no special needs, leave it empty.
	ControlParams *CommonMixControlParams `json:"ControlParams,omitnil,omitempty" name:"ControlParams"`
}

func (r *CreateCommonMixStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateCommonMixStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "MixStreamSessionId")
	delete(f, "InputStreamList")
	delete(f, "OutputParams")
	delete(f, "MixStreamTemplateId")
	delete(f, "ControlParams")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateCommonMixStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateCommonMixStreamResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateCommonMixStreamResponse struct {
	*tchttp.BaseResponse
	Response *CreateCommonMixStreamResponseParams `json:"Response"`
}

func (r *CreateCommonMixStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateCommonMixStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveCallbackRuleRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type CreateLiveCallbackRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *CreateLiveCallbackRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveCallbackRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveCallbackRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveCallbackRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveCallbackRuleResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveCallbackRuleResponseParams `json:"Response"`
}

func (r *CreateLiveCallbackRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveCallbackRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveCallbackTemplateRequestParams struct {
	// Template name.
	// Maximum length: 255 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Description.
	// Maximum length: 1,024 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Stream starting callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	StreamBeginNotifyUrl *string `json:"StreamBeginNotifyUrl,omitnil,omitempty" name:"StreamBeginNotifyUrl"`

	// Interruption callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	StreamEndNotifyUrl *string `json:"StreamEndNotifyUrl,omitnil,omitempty" name:"StreamEndNotifyUrl"`

	// Recording callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	RecordNotifyUrl *string `json:"RecordNotifyUrl,omitnil,omitempty" name:"RecordNotifyUrl"`

	// Screencapturing callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	SnapshotNotifyUrl *string `json:"SnapshotNotifyUrl,omitnil,omitempty" name:"SnapshotNotifyUrl"`

	// Porn detection callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32741?from_cn_redirect=1).
	PornCensorshipNotifyUrl *string `json:"PornCensorshipNotifyUrl,omitnil,omitempty" name:"PornCensorshipNotifyUrl"`

	// Callback key. The callback URL is public. For the callback signature, please see the event message notification document.
	// [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	CallbackKey *string `json:"CallbackKey,omitnil,omitempty" name:"CallbackKey"`

	// Disused
	StreamMixNotifyUrl *string `json:"StreamMixNotifyUrl,omitnil,omitempty" name:"StreamMixNotifyUrl"`

	// The push error callback URL.
	PushExceptionNotifyUrl *string `json:"PushExceptionNotifyUrl,omitnil,omitempty" name:"PushExceptionNotifyUrl"`
}

type CreateLiveCallbackTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template name.
	// Maximum length: 255 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Description.
	// Maximum length: 1,024 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Stream starting callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	StreamBeginNotifyUrl *string `json:"StreamBeginNotifyUrl,omitnil,omitempty" name:"StreamBeginNotifyUrl"`

	// Interruption callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	StreamEndNotifyUrl *string `json:"StreamEndNotifyUrl,omitnil,omitempty" name:"StreamEndNotifyUrl"`

	// Recording callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	RecordNotifyUrl *string `json:"RecordNotifyUrl,omitnil,omitempty" name:"RecordNotifyUrl"`

	// Screencapturing callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	SnapshotNotifyUrl *string `json:"SnapshotNotifyUrl,omitnil,omitempty" name:"SnapshotNotifyUrl"`

	// Porn detection callback URL,
	// Protocol document: [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32741?from_cn_redirect=1).
	PornCensorshipNotifyUrl *string `json:"PornCensorshipNotifyUrl,omitnil,omitempty" name:"PornCensorshipNotifyUrl"`

	// Callback key. The callback URL is public. For the callback signature, please see the event message notification document.
	// [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	CallbackKey *string `json:"CallbackKey,omitnil,omitempty" name:"CallbackKey"`

	// Disused
	StreamMixNotifyUrl *string `json:"StreamMixNotifyUrl,omitnil,omitempty" name:"StreamMixNotifyUrl"`

	// The push error callback URL.
	PushExceptionNotifyUrl *string `json:"PushExceptionNotifyUrl,omitnil,omitempty" name:"PushExceptionNotifyUrl"`
}

func (r *CreateLiveCallbackTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveCallbackTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateName")
	delete(f, "Description")
	delete(f, "StreamBeginNotifyUrl")
	delete(f, "StreamEndNotifyUrl")
	delete(f, "RecordNotifyUrl")
	delete(f, "SnapshotNotifyUrl")
	delete(f, "PornCensorshipNotifyUrl")
	delete(f, "CallbackKey")
	delete(f, "StreamMixNotifyUrl")
	delete(f, "PushExceptionNotifyUrl")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveCallbackTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveCallbackTemplateResponseParams struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveCallbackTemplateResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveCallbackTemplateResponseParams `json:"Response"`
}

func (r *CreateLiveCallbackTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveCallbackTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLivePullStreamTaskRequestParams struct {
	// The source type. Valid values:
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// PullPicPushLive: Images
	SourceType *string `json:"SourceType,omitnil,omitempty" name:"SourceType"`

	// The source URL(s).
	// If `SourceType` is `PullLivePushLive`, you can specify only one source URL.
	// If `SourceType` is `PullVodPushLive`, you can specify at most 30 source URLs.
	// Supported file formats: FLV, MP4, HLS.
	// Supported protocols: HTTP, HTTPS, RTMP, RTMPS, RTSP, SRT.
	// Notes:
	// 1. We recommend you use FLV files as the source. Poorly interleaved MP4 files may result in playback stuttering. You can also re-interleave your MP4 files before adding them as the source.
	// 2. Do not use private network domains or malicious URLs. CSS will block accounts that do.
	// 3. To avoid push and playback issues, make sure the source files are properly interleaved.
	// 4. Supported video coding formats: H.264, H.265.
	// 5. Supported audio coding format: AAC.
	// 6. Use small video files, preferably not longer than one hour. Large files may take a long time to load or resume after pause. Relay may fail if the time consumed exceeds 15 seconds.
	SourceUrls []*string `json:"SourceUrls,omitnil,omitempty" name:"SourceUrls"`

	// The push domain name.
	// The pulled stream is pushed to this domain.
	// Note: If the destination is not a CSS address and its format is different from that of CSS addresses, pass the full address to `ToUrl`. For details, see the description of the `ToUrl` parameter.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The application to push to.
	// The pulled stream is pushed to this application.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	// The pulled stream is pushed under this name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The start time.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time. Notes:
	// 1. The end time must be later than the start time.
	// 2. The end time and start time must be later than the current time.
	// 3. The end time and start time must be less than seven days apart.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`

	// The push parameter.
	// This is a custom parameter carried during push.
	// Example:
	// bak=1&test=2
	PushArgs *string `json:"PushArgs,omitnil,omitempty" name:"PushArgs"`

	// The events to listen for. If you do not pass this parameter, all events will be listened for.
	// TaskStart: Callback for starting a task
	// TaskExit: Callback for ending a task
	// VodSourceFileStart: Callback for starting to pull from video files
	// VodSourceFileFinish: Callback for stopping pulling from video files
	// ResetTaskConfig: Callback for modifying a task
	// 
	// `TaskAlarm` indicates a warning event. `AlarmType` examples:
	// PullFileUnstable: Pull from video files is unstable.
	// PushStreamUnstable: Push is unstable.
	// PullFileFailed: Error pulling from video files.
	// PushStreamFailed: Push error.
	// FileEndEarly: The video file ended prematurely.
	CallbackEvents []*string `json:"CallbackEvents,omitnil,omitempty" name:"CallbackEvents"`

	// The number of times to loop video files. Default value: -1.
	// -1: Loop indefinitely
	// 0: Do not loop
	// > 0: The number of loop times. A task will end either when the videos are looped for the specified number of times or at the specified task end time, whichever is earlier.
	// This parameter is valid only when the source is video files.
	VodLoopTimes *string `json:"VodLoopTimes,omitnil,omitempty" name:"VodLoopTimes"`

	// The behavior after the source video files (`SourceUrls`) are changed.
	// ImmediateNewSource: Play the new videos immediately
	// ContinueBreakPoint: Play the new videos after the current video is finished playing (the remaining videos in the old playlist will not be played).
	// 
	// This parameter is valid only if the source before the change is video files.
	VodRefreshType *string `json:"VodRefreshType,omitnil,omitempty" name:"VodRefreshType"`

	// A custom callback URL.
	// Callbacks about pull and relay events will be sent to this URL.
	CallbackUrl *string `json:"CallbackUrl,omitnil,omitempty" name:"CallbackUrl"`

	// Other parameters.
	// For example, you can use `ignore_region` to ignore the region passed in and assign a region based on load distribution.
	ExtraCmd *string `json:"ExtraCmd,omitnil,omitempty" name:"ExtraCmd"`

	// The remarks for a task, not longer than 512 bytes.
	Comment *string `json:"Comment,omitnil,omitempty" name:"Comment"`

	// The complete destination URL.
	// If you specify this parameter, make sure you pass in an empty string for `DomainName`, `AppName`, and `StreamName`.
	// 
	// Note: Make sure that the expiration time of the signature is later than the task end time.
	ToUrl *string `json:"ToUrl,omitnil,omitempty" name:"ToUrl"`

	// The backup source type.
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// Notes:
	// 1. Backup sources are supported only if the primary source type is live streaming.
	// 2. When pull from the primary source is interrupted, the system will pull from the backup source.
	// 3. If the backup source is a video file, each time the video is finished, the system will check if the primary source is recovered and will switch back if it is.
	BackupSourceType *string `json:"BackupSourceType,omitnil,omitempty" name:"BackupSourceType"`

	// The URL of the backup source.
	// You can specify only one backup source URL.
	BackupSourceUrl *string `json:"BackupSourceUrl,omitnil,omitempty" name:"BackupSourceUrl"`

	// The information of watermarks to add.
	// Notes:
	// 1. You can add up to four watermarks to different locations of the video.
	// 2. Make sure you use publicly accessible URLs for the watermark images.
	// 3. Supported image formats include PNG, JPG, and GIF.
	WatermarkList []*PullPushWatermarkInfo `json:"WatermarkList,omitnil,omitempty" name:"WatermarkList"`

	// Whether to use local mode when the source type is video files. The default is `0`.
	// 0: Do not use local mode
	// 1: Use local mode
	// Note: If you enable local mode, MP4 files will be downloaded to local storage, and the local files will be used for push. This ensures more reliable push. Pushing a local file will incur additional fees.
	VodLocalMode *int64 `json:"VodLocalMode,omitnil,omitempty" name:"VodLocalMode"`
}

type CreateLivePullStreamTaskRequest struct {
	*tchttp.BaseRequest
	
	// The source type. Valid values:
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// PullPicPushLive: Images
	SourceType *string `json:"SourceType,omitnil,omitempty" name:"SourceType"`

	// The source URL(s).
	// If `SourceType` is `PullLivePushLive`, you can specify only one source URL.
	// If `SourceType` is `PullVodPushLive`, you can specify at most 30 source URLs.
	// Supported file formats: FLV, MP4, HLS.
	// Supported protocols: HTTP, HTTPS, RTMP, RTMPS, RTSP, SRT.
	// Notes:
	// 1. We recommend you use FLV files as the source. Poorly interleaved MP4 files may result in playback stuttering. You can also re-interleave your MP4 files before adding them as the source.
	// 2. Do not use private network domains or malicious URLs. CSS will block accounts that do.
	// 3. To avoid push and playback issues, make sure the source files are properly interleaved.
	// 4. Supported video coding formats: H.264, H.265.
	// 5. Supported audio coding format: AAC.
	// 6. Use small video files, preferably not longer than one hour. Large files may take a long time to load or resume after pause. Relay may fail if the time consumed exceeds 15 seconds.
	SourceUrls []*string `json:"SourceUrls,omitnil,omitempty" name:"SourceUrls"`

	// The push domain name.
	// The pulled stream is pushed to this domain.
	// Note: If the destination is not a CSS address and its format is different from that of CSS addresses, pass the full address to `ToUrl`. For details, see the description of the `ToUrl` parameter.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The application to push to.
	// The pulled stream is pushed to this application.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	// The pulled stream is pushed under this name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The start time.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time. Notes:
	// 1. The end time must be later than the start time.
	// 2. The end time and start time must be later than the current time.
	// 3. The end time and start time must be less than seven days apart.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`

	// The push parameter.
	// This is a custom parameter carried during push.
	// Example:
	// bak=1&test=2
	PushArgs *string `json:"PushArgs,omitnil,omitempty" name:"PushArgs"`

	// The events to listen for. If you do not pass this parameter, all events will be listened for.
	// TaskStart: Callback for starting a task
	// TaskExit: Callback for ending a task
	// VodSourceFileStart: Callback for starting to pull from video files
	// VodSourceFileFinish: Callback for stopping pulling from video files
	// ResetTaskConfig: Callback for modifying a task
	// 
	// `TaskAlarm` indicates a warning event. `AlarmType` examples:
	// PullFileUnstable: Pull from video files is unstable.
	// PushStreamUnstable: Push is unstable.
	// PullFileFailed: Error pulling from video files.
	// PushStreamFailed: Push error.
	// FileEndEarly: The video file ended prematurely.
	CallbackEvents []*string `json:"CallbackEvents,omitnil,omitempty" name:"CallbackEvents"`

	// The number of times to loop video files. Default value: -1.
	// -1: Loop indefinitely
	// 0: Do not loop
	// > 0: The number of loop times. A task will end either when the videos are looped for the specified number of times or at the specified task end time, whichever is earlier.
	// This parameter is valid only when the source is video files.
	VodLoopTimes *string `json:"VodLoopTimes,omitnil,omitempty" name:"VodLoopTimes"`

	// The behavior after the source video files (`SourceUrls`) are changed.
	// ImmediateNewSource: Play the new videos immediately
	// ContinueBreakPoint: Play the new videos after the current video is finished playing (the remaining videos in the old playlist will not be played).
	// 
	// This parameter is valid only if the source before the change is video files.
	VodRefreshType *string `json:"VodRefreshType,omitnil,omitempty" name:"VodRefreshType"`

	// A custom callback URL.
	// Callbacks about pull and relay events will be sent to this URL.
	CallbackUrl *string `json:"CallbackUrl,omitnil,omitempty" name:"CallbackUrl"`

	// Other parameters.
	// For example, you can use `ignore_region` to ignore the region passed in and assign a region based on load distribution.
	ExtraCmd *string `json:"ExtraCmd,omitnil,omitempty" name:"ExtraCmd"`

	// The remarks for a task, not longer than 512 bytes.
	Comment *string `json:"Comment,omitnil,omitempty" name:"Comment"`

	// The complete destination URL.
	// If you specify this parameter, make sure you pass in an empty string for `DomainName`, `AppName`, and `StreamName`.
	// 
	// Note: Make sure that the expiration time of the signature is later than the task end time.
	ToUrl *string `json:"ToUrl,omitnil,omitempty" name:"ToUrl"`

	// The backup source type.
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// Notes:
	// 1. Backup sources are supported only if the primary source type is live streaming.
	// 2. When pull from the primary source is interrupted, the system will pull from the backup source.
	// 3. If the backup source is a video file, each time the video is finished, the system will check if the primary source is recovered and will switch back if it is.
	BackupSourceType *string `json:"BackupSourceType,omitnil,omitempty" name:"BackupSourceType"`

	// The URL of the backup source.
	// You can specify only one backup source URL.
	BackupSourceUrl *string `json:"BackupSourceUrl,omitnil,omitempty" name:"BackupSourceUrl"`

	// The information of watermarks to add.
	// Notes:
	// 1. You can add up to four watermarks to different locations of the video.
	// 2. Make sure you use publicly accessible URLs for the watermark images.
	// 3. Supported image formats include PNG, JPG, and GIF.
	WatermarkList []*PullPushWatermarkInfo `json:"WatermarkList,omitnil,omitempty" name:"WatermarkList"`

	// Whether to use local mode when the source type is video files. The default is `0`.
	// 0: Do not use local mode
	// 1: Use local mode
	// Note: If you enable local mode, MP4 files will be downloaded to local storage, and the local files will be used for push. This ensures more reliable push. Pushing a local file will incur additional fees.
	VodLocalMode *int64 `json:"VodLocalMode,omitnil,omitempty" name:"VodLocalMode"`
}

func (r *CreateLivePullStreamTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLivePullStreamTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "SourceType")
	delete(f, "SourceUrls")
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "Operator")
	delete(f, "PushArgs")
	delete(f, "CallbackEvents")
	delete(f, "VodLoopTimes")
	delete(f, "VodRefreshType")
	delete(f, "CallbackUrl")
	delete(f, "ExtraCmd")
	delete(f, "Comment")
	delete(f, "ToUrl")
	delete(f, "BackupSourceType")
	delete(f, "BackupSourceUrl")
	delete(f, "WatermarkList")
	delete(f, "VodLocalMode")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLivePullStreamTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLivePullStreamTaskResponseParams struct {
	// The task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLivePullStreamTaskResponse struct {
	*tchttp.BaseResponse
	Response *CreateLivePullStreamTaskResponseParams `json:"Response"`
}

func (r *CreateLivePullStreamTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLivePullStreamTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveRecordRequestParams struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name. This parameter must be set for multi-domain name push.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Recording start time, which is China standard time and should be URL-encoded (RFC3986). For example, the encoding of 2017-01-01 10:10:01 is 2017-01-01+10%3a10%3a01.
	// In scheduled recording mode, this field must be set; in real-time video recording mode, this field is ignored.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// Recording end time, which is China standard time and should be URL-encoded (RFC3986). For example, the encoding of 2017-01-01 10:30:01 is 2017-01-01+10%3a30%3a01.
	// In scheduled recording mode, this field must be set; in real-time video recording mode, this field is optional. If the recording is set to real-time video recording mode through the `Highlight` parameter, the set end time should not be more than 30 minutes after the current time. If the set end time is more than 30 minutes after the current time, earlier than the current time, or left empty, the actual end time will be 30 minutes after the current time.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Recording type.
	// "video": Audio-video recording **(default)**.
	// "audio": audio recording.
	// In both scheduled and real-time video recording modes, this parameter is valid and is not case sensitive.
	RecordType *string `json:"RecordType,omitnil,omitempty" name:"RecordType"`

	// Recording file format. Valid values:
	// "flv" **(default)**, "hls", "mp4", "aac", "mp3".
	// In both scheduled and real-time video recording modes, this parameter is valid and is not case sensitive.
	FileFormat *string `json:"FileFormat,omitnil,omitempty" name:"FileFormat"`

	// Mark for enabling real-time video recording mode.
	// 0: Real-time video recording mode is not enabled, i.e., the scheduled recording mode is used **(default)**. See [Sample 1](#.E7.A4.BA.E4.BE.8B1-.E5.88.9B.E5.BB.BA.E5.AE.9A.E6.97.B6.E5.BD.95.E5.88.B6.E4.BB.BB.E5.8A.A1).
	// 1: Real-time video recording mode is enabled. See [Sample 2](#.E7.A4.BA.E4.BE.8B2-.E5.88.9B.E5.BB.BA.E5.AE.9E.E6.97.B6.E5.BD.95.E5.88.B6.E4.BB.BB.E5.8A.A1).
	Highlight *int64 `json:"Highlight,omitnil,omitempty" name:"Highlight"`

	// Flag for enabling A+B=C mixed stream recording.
	// 0: A+B=C mixed stream recording is not enabled **(default)**.
	// 1: A+B=C mixed stream recording is enabled.
	// In both scheduled and real-time video recording modes, this parameter is valid.
	MixStream *int64 `json:"MixStream,omitnil,omitempty" name:"MixStream"`

	// Recording stream parameter. The following parameters are supported currently:
	// record_interval: recording interval in seconds. Value range: 1800-7200.
	// storage_time: recording file storage duration in seconds.
	// Example: record_interval=3600&storage_time=2592000.
	// Note: the parameter needs to be URL-encoded.
	// In both scheduled and real-time video recording modes, this parameter is valid.
	StreamParam *string `json:"StreamParam,omitnil,omitempty" name:"StreamParam"`
}

type CreateLiveRecordRequest struct {
	*tchttp.BaseRequest
	
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name. This parameter must be set for multi-domain name push.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Recording start time, which is China standard time and should be URL-encoded (RFC3986). For example, the encoding of 2017-01-01 10:10:01 is 2017-01-01+10%3a10%3a01.
	// In scheduled recording mode, this field must be set; in real-time video recording mode, this field is ignored.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// Recording end time, which is China standard time and should be URL-encoded (RFC3986). For example, the encoding of 2017-01-01 10:30:01 is 2017-01-01+10%3a30%3a01.
	// In scheduled recording mode, this field must be set; in real-time video recording mode, this field is optional. If the recording is set to real-time video recording mode through the `Highlight` parameter, the set end time should not be more than 30 minutes after the current time. If the set end time is more than 30 minutes after the current time, earlier than the current time, or left empty, the actual end time will be 30 minutes after the current time.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Recording type.
	// "video": Audio-video recording **(default)**.
	// "audio": audio recording.
	// In both scheduled and real-time video recording modes, this parameter is valid and is not case sensitive.
	RecordType *string `json:"RecordType,omitnil,omitempty" name:"RecordType"`

	// Recording file format. Valid values:
	// "flv" **(default)**, "hls", "mp4", "aac", "mp3".
	// In both scheduled and real-time video recording modes, this parameter is valid and is not case sensitive.
	FileFormat *string `json:"FileFormat,omitnil,omitempty" name:"FileFormat"`

	// Mark for enabling real-time video recording mode.
	// 0: Real-time video recording mode is not enabled, i.e., the scheduled recording mode is used **(default)**. See [Sample 1](#.E7.A4.BA.E4.BE.8B1-.E5.88.9B.E5.BB.BA.E5.AE.9A.E6.97.B6.E5.BD.95.E5.88.B6.E4.BB.BB.E5.8A.A1).
	// 1: Real-time video recording mode is enabled. See [Sample 2](#.E7.A4.BA.E4.BE.8B2-.E5.88.9B.E5.BB.BA.E5.AE.9E.E6.97.B6.E5.BD.95.E5.88.B6.E4.BB.BB.E5.8A.A1).
	Highlight *int64 `json:"Highlight,omitnil,omitempty" name:"Highlight"`

	// Flag for enabling A+B=C mixed stream recording.
	// 0: A+B=C mixed stream recording is not enabled **(default)**.
	// 1: A+B=C mixed stream recording is enabled.
	// In both scheduled and real-time video recording modes, this parameter is valid.
	MixStream *int64 `json:"MixStream,omitnil,omitempty" name:"MixStream"`

	// Recording stream parameter. The following parameters are supported currently:
	// record_interval: recording interval in seconds. Value range: 1800-7200.
	// storage_time: recording file storage duration in seconds.
	// Example: record_interval=3600&storage_time=2592000.
	// Note: the parameter needs to be URL-encoded.
	// In both scheduled and real-time video recording modes, this parameter is valid.
	StreamParam *string `json:"StreamParam,omitnil,omitempty" name:"StreamParam"`
}

func (r *CreateLiveRecordRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveRecordRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StreamName")
	delete(f, "AppName")
	delete(f, "DomainName")
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "RecordType")
	delete(f, "FileFormat")
	delete(f, "Highlight")
	delete(f, "MixStream")
	delete(f, "StreamParam")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveRecordRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveRecordResponseParams struct {
	// Task ID, which uniquely identifies a recording task globally.
	TaskId *uint64 `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveRecordResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveRecordResponseParams `json:"Response"`
}

func (r *CreateLiveRecordResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveRecordResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveRecordRuleRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	// Note: If the parameter is a non-empty string, the rule will be only applicable to the particular stream.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type CreateLiveRecordRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	// Note: If the parameter is a non-empty string, the rule will be only applicable to the particular stream.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *CreateLiveRecordRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveRecordRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "TemplateId")
	delete(f, "AppName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveRecordRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveRecordRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveRecordRuleResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveRecordRuleResponseParams `json:"Response"`
}

func (r *CreateLiveRecordRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveRecordRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveRecordTemplateRequestParams struct {
	// Template name. Only letters, digits, underscores, and hyphens can be contained.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Message description
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// FLV recording parameter, which is set when FLV recording is enabled.
	FlvParam *RecordParam `json:"FlvParam,omitnil,omitempty" name:"FlvParam"`

	// HLS recording parameter, which is set when HLS recording is enabled.
	HlsParam *RecordParam `json:"HlsParam,omitnil,omitempty" name:"HlsParam"`

	// Mp4 recording parameter, which is set when Mp4 recording is enabled.
	Mp4Param *RecordParam `json:"Mp4Param,omitnil,omitempty" name:"Mp4Param"`

	// AAC recording parameter, which is set when AAC recording is enabled.
	AacParam *RecordParam `json:"AacParam,omitnil,omitempty" name:"AacParam"`

	// LVB type. Default value: 0.
	// 0: LVB.
	// 1: LCB.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// HLS-specific recording parameter.
	HlsSpecialParam *HlsSpecialParam `json:"HlsSpecialParam,omitnil,omitempty" name:"HlsSpecialParam"`

	// Mp3 recording parameter, which is set when Mp3 recording is enabled.
	Mp3Param *RecordParam `json:"Mp3Param,omitnil,omitempty" name:"Mp3Param"`

	// Whether to remove the watermark. This parameter is invalid if `IsDelayLive` is `1`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// A special parameter for FLV recording.
	FlvSpecialParam *FlvSpecialParam `json:"FlvSpecialParam,omitnil,omitempty" name:"FlvSpecialParam"`
}

type CreateLiveRecordTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template name. Only letters, digits, underscores, and hyphens can be contained.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Message description
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// FLV recording parameter, which is set when FLV recording is enabled.
	FlvParam *RecordParam `json:"FlvParam,omitnil,omitempty" name:"FlvParam"`

	// HLS recording parameter, which is set when HLS recording is enabled.
	HlsParam *RecordParam `json:"HlsParam,omitnil,omitempty" name:"HlsParam"`

	// Mp4 recording parameter, which is set when Mp4 recording is enabled.
	Mp4Param *RecordParam `json:"Mp4Param,omitnil,omitempty" name:"Mp4Param"`

	// AAC recording parameter, which is set when AAC recording is enabled.
	AacParam *RecordParam `json:"AacParam,omitnil,omitempty" name:"AacParam"`

	// LVB type. Default value: 0.
	// 0: LVB.
	// 1: LCB.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// HLS-specific recording parameter.
	HlsSpecialParam *HlsSpecialParam `json:"HlsSpecialParam,omitnil,omitempty" name:"HlsSpecialParam"`

	// Mp3 recording parameter, which is set when Mp3 recording is enabled.
	Mp3Param *RecordParam `json:"Mp3Param,omitnil,omitempty" name:"Mp3Param"`

	// Whether to remove the watermark. This parameter is invalid if `IsDelayLive` is `1`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// A special parameter for FLV recording.
	FlvSpecialParam *FlvSpecialParam `json:"FlvSpecialParam,omitnil,omitempty" name:"FlvSpecialParam"`
}

func (r *CreateLiveRecordTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveRecordTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateName")
	delete(f, "Description")
	delete(f, "FlvParam")
	delete(f, "HlsParam")
	delete(f, "Mp4Param")
	delete(f, "AacParam")
	delete(f, "IsDelayLive")
	delete(f, "HlsSpecialParam")
	delete(f, "Mp3Param")
	delete(f, "RemoveWatermark")
	delete(f, "FlvSpecialParam")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveRecordTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveRecordTemplateResponseParams struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveRecordTemplateResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveRecordTemplateResponseParams `json:"Response"`
}

func (r *CreateLiveRecordTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveRecordTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveSnapshotRuleRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	// Note: if this parameter is a non-empty string, the rule will take effect only for the particular stream.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type CreateLiveSnapshotRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	// Note: if this parameter is a non-empty string, the rule will take effect only for the particular stream.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *CreateLiveSnapshotRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveSnapshotRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "TemplateId")
	delete(f, "AppName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveSnapshotRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveSnapshotRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveSnapshotRuleResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveSnapshotRuleResponseParams `json:"Response"`
}

func (r *CreateLiveSnapshotRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveSnapshotRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveSnapshotTemplateRequestParams struct {
	// Template name.
	// Maximum length: 255 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// COS application ID.
	CosAppId *int64 `json:"CosAppId,omitnil,omitempty" name:"CosAppId"`

	// COS bucket name.
	// Note: the value of `CosBucket` cannot contain `-[appid]`.
	CosBucket *string `json:"CosBucket,omitnil,omitempty" name:"CosBucket"`

	// COS region.
	CosRegion *string `json:"CosRegion,omitnil,omitempty" name:"CosRegion"`

	// Description.
	// Maximum length: 1,024 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Screencapturing interval (s). Default value: 10
	// Value range: 2-300
	SnapshotInterval *int64 `json:"SnapshotInterval,omitnil,omitempty" name:"SnapshotInterval"`

	// Screenshot width. Default value: `0` (original width)
	// Value range: 0-3000
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Screenshot height. Default value: `0` (original height)
	// Value range: 0-2000
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Whether to enable porn detection. 0: no, 1: yes. Default value: 0
	PornFlag *int64 `json:"PornFlag,omitnil,omitempty" name:"PornFlag"`

	// COS Bucket folder prefix.
	// If no value is entered, the default value
	// `/{Year}-{Month}-{Day}`
	// will be used.
	CosPrefix *string `json:"CosPrefix,omitnil,omitempty" name:"CosPrefix"`

	// COS filename.
	// If no value is entered, the default value 
	// `{StreamID}-screenshot-{Hour}-{Minute}-{Second}-{Width}x{Height}{Ext}`
	// will be used.
	CosFileName *string `json:"CosFileName,omitnil,omitempty" name:"CosFileName"`
}

type CreateLiveSnapshotTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template name.
	// Maximum length: 255 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// COS application ID.
	CosAppId *int64 `json:"CosAppId,omitnil,omitempty" name:"CosAppId"`

	// COS bucket name.
	// Note: the value of `CosBucket` cannot contain `-[appid]`.
	CosBucket *string `json:"CosBucket,omitnil,omitempty" name:"CosBucket"`

	// COS region.
	CosRegion *string `json:"CosRegion,omitnil,omitempty" name:"CosRegion"`

	// Description.
	// Maximum length: 1,024 bytes.
	// Only letters, digits, underscores, and hyphens can be contained.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Screencapturing interval (s). Default value: 10
	// Value range: 2-300
	SnapshotInterval *int64 `json:"SnapshotInterval,omitnil,omitempty" name:"SnapshotInterval"`

	// Screenshot width. Default value: `0` (original width)
	// Value range: 0-3000
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Screenshot height. Default value: `0` (original height)
	// Value range: 0-2000
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Whether to enable porn detection. 0: no, 1: yes. Default value: 0
	PornFlag *int64 `json:"PornFlag,omitnil,omitempty" name:"PornFlag"`

	// COS Bucket folder prefix.
	// If no value is entered, the default value
	// `/{Year}-{Month}-{Day}`
	// will be used.
	CosPrefix *string `json:"CosPrefix,omitnil,omitempty" name:"CosPrefix"`

	// COS filename.
	// If no value is entered, the default value 
	// `{StreamID}-screenshot-{Hour}-{Minute}-{Second}-{Width}x{Height}{Ext}`
	// will be used.
	CosFileName *string `json:"CosFileName,omitnil,omitempty" name:"CosFileName"`
}

func (r *CreateLiveSnapshotTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveSnapshotTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateName")
	delete(f, "CosAppId")
	delete(f, "CosBucket")
	delete(f, "CosRegion")
	delete(f, "Description")
	delete(f, "SnapshotInterval")
	delete(f, "Width")
	delete(f, "Height")
	delete(f, "PornFlag")
	delete(f, "CosPrefix")
	delete(f, "CosFileName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveSnapshotTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveSnapshotTemplateResponseParams struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveSnapshotTemplateResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveSnapshotTemplateResponseParams `json:"Response"`
}

func (r *CreateLiveSnapshotTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveSnapshotTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTimeShiftRuleRequestParams struct {
	// The push domain.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which should be the same as `AppName` in the push and playback URLs. The default value is `live`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	// Note: If you pass in a non-empty string, the rule will only be applied to the specified stream.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type CreateLiveTimeShiftRuleRequest struct {
	*tchttp.BaseRequest
	
	// The push domain.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which should be the same as `AppName` in the push and playback URLs. The default value is `live`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	// Note: If you pass in a non-empty string, the rule will only be applied to the specified stream.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *CreateLiveTimeShiftRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTimeShiftRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveTimeShiftRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTimeShiftRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveTimeShiftRuleResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveTimeShiftRuleResponseParams `json:"Response"`
}

func (r *CreateLiveTimeShiftRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTimeShiftRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTimeShiftTemplateRequestParams struct {
	// The template name.
	// Maximum length: 255 bytes.
	// Only letters, numbers, underscores, and hyphens are supported.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// The time shifting duration.
	// Unit: Second.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// The template description.
	// Only letters, numbers, underscores, and hyphens are supported.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// The region.
	// `Mainland`: The Chinese mainland.
	// `Overseas`: Outside the Chinese mainland.
	// Default value: `Mainland`.
	Area *string `json:"Area,omitnil,omitempty" name:"Area"`

	// The segment size.
	// Value range: 3-10.
	// Unit: Second.
	// Default value: 5
	ItemDuration *uint64 `json:"ItemDuration,omitnil,omitempty" name:"ItemDuration"`

	// Whether to remove watermarks.
	// If you pass in `true`, the original stream will be recorded.
	// Default value: `false`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// The transcoding template IDs.
	// This API works only if `RemoveWatermark` is `false`.
	TranscodeTemplateIds []*int64 `json:"TranscodeTemplateIds,omitnil,omitempty" name:"TranscodeTemplateIds"`
}

type CreateLiveTimeShiftTemplateRequest struct {
	*tchttp.BaseRequest
	
	// The template name.
	// Maximum length: 255 bytes.
	// Only letters, numbers, underscores, and hyphens are supported.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// The time shifting duration.
	// Unit: Second.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// The template description.
	// Only letters, numbers, underscores, and hyphens are supported.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// The region.
	// `Mainland`: The Chinese mainland.
	// `Overseas`: Outside the Chinese mainland.
	// Default value: `Mainland`.
	Area *string `json:"Area,omitnil,omitempty" name:"Area"`

	// The segment size.
	// Value range: 3-10.
	// Unit: Second.
	// Default value: 5
	ItemDuration *uint64 `json:"ItemDuration,omitnil,omitempty" name:"ItemDuration"`

	// Whether to remove watermarks.
	// If you pass in `true`, the original stream will be recorded.
	// Default value: `false`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// The transcoding template IDs.
	// This API works only if `RemoveWatermark` is `false`.
	TranscodeTemplateIds []*int64 `json:"TranscodeTemplateIds,omitnil,omitempty" name:"TranscodeTemplateIds"`
}

func (r *CreateLiveTimeShiftTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTimeShiftTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateName")
	delete(f, "Duration")
	delete(f, "Description")
	delete(f, "Area")
	delete(f, "ItemDuration")
	delete(f, "RemoveWatermark")
	delete(f, "TranscodeTemplateIds")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveTimeShiftTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTimeShiftTemplateResponseParams struct {
	// The template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveTimeShiftTemplateResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveTimeShiftTemplateResponseParams `json:"Response"`
}

func (r *CreateLiveTimeShiftTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTimeShiftTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTranscodeRuleRequestParams struct {
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which is the same as `AppName` in the push and playback addresses and is `live` by default. If you only want to bind the template to a domain, pass in an empty string.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name. If only the domain name or path is bound, leave this parameter blank.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Designates an existing template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type CreateLiveTranscodeRuleRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which is the same as `AppName` in the push and playback addresses and is `live` by default. If you only want to bind the template to a domain, pass in an empty string.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name. If only the domain name or path is bound, leave this parameter blank.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Designates an existing template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *CreateLiveTranscodeRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTranscodeRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveTranscodeRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTranscodeRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveTranscodeRuleResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveTranscodeRuleResponseParams `json:"Response"`
}

func (r *CreateLiveTranscodeRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTranscodeRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTranscodeTemplateRequestParams struct {
	// Template name, such as “900p”. This can be only a combination of letters and digits.
	// Length limit:
	//   Standard transcoding: 1-10 characters
	//   Top speed codec transcoding: 3-10 characters
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Video bitrate in Kbps. Value range: 100-8000.
	// Note: the transcoding template requires that the bitrate be unique. Therefore, the final saved bitrate may be different from the input bitrate.
	VideoBitrate *int64 `json:"VideoBitrate,omitnil,omitempty" name:"VideoBitrate"`

	// Audio codec. Default value: aac.
	// Note: this parameter is unsupported now.
	Acodec *string `json:"Acodec,omitnil,omitempty" name:"Acodec"`

	// Audio bitrate. Default value: 0.
	// Value range: 0-500.
	AudioBitrate *int64 `json:"AudioBitrate,omitnil,omitempty" name:"AudioBitrate"`

	// Video codec. Valid values: h264, h265, origin (default)
	// 
	// origin: original codec as the output codec
	Vcodec *string `json:"Vcodec,omitnil,omitempty" name:"Vcodec"`

	// Template description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Whether to keep the video. 0: no; 1: yes. Default value: 1.
	NeedVideo *int64 `json:"NeedVideo,omitnil,omitempty" name:"NeedVideo"`

	// Width. Default value: 0.
	// Value range: 0-3000
	// It must be a multiple of 2. The original width is 0.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Whether to keep the audio. 0: no; 1: yes. Default value: 1.
	NeedAudio *int64 `json:"NeedAudio,omitnil,omitempty" name:"NeedAudio"`

	// Height. Default value: 0
	// Value range: 0-3000
	// The value must be a multiple of 2. The original height is `0`.
	// This parameter is required for a top speed codec template (when `AiTransCode` is `1`).
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Frame rate. Default value: 0.
	// Value range: 0-60
	Fps *int64 `json:"Fps,omitnil,omitempty" name:"Fps"`

	// Keyframe interval in seconds. Default value: original interval
	// Value range: 2-6
	Gop *int64 `json:"Gop,omitnil,omitempty" name:"Gop"`

	// Rotation angle. Default value: 0.
	// Valid values: 0, 90, 180, 270
	Rotate *int64 `json:"Rotate,omitnil,omitempty" name:"Rotate"`

	// Encoding quality:
	// baseline/main/high. Default value: baseline.
	Profile *string `json:"Profile,omitnil,omitempty" name:"Profile"`

	// Whether to use the original bitrate when the set bitrate is larger than the original bitrate.
	// 0: no, 1: yes
	// Default value: 0.
	BitrateToOrig *int64 `json:"BitrateToOrig,omitnil,omitempty" name:"BitrateToOrig"`

	// Whether to use the original height when the set height is higher than the original height.
	// 0: no, 1: yes
	// Default value: 0.
	HeightToOrig *int64 `json:"HeightToOrig,omitnil,omitempty" name:"HeightToOrig"`

	// Whether to use the original frame rate when the set frame rate is larger than the original frame rate.
	// 0: no, 1: yes
	// Default value: 0.
	FpsToOrig *int64 `json:"FpsToOrig,omitnil,omitempty" name:"FpsToOrig"`

	// Whether it is a top speed codec template. 0: no, 1: yes. Default value: 0.
	AiTransCode *int64 `json:"AiTransCode,omitnil,omitempty" name:"AiTransCode"`

	// Bitrate compression ratio of top speed codec video.
	// Target bitrate of top speed code = VideoBitrate * (1-AdaptBitratePercent)
	// 
	// Value range: 0.0-0.5.
	AdaptBitratePercent *float64 `json:"AdaptBitratePercent,omitnil,omitempty" name:"AdaptBitratePercent"`

	// Whether to use the short side as the video height. 0: no, 1: yes. Default value: 0.
	ShortEdgeAsHeight *int64 `json:"ShortEdgeAsHeight,omitnil,omitempty" name:"ShortEdgeAsHeight"`

	// The DRM encryption type. Valid values: fairplay, normalaes, widevine.
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMType *string `json:"DRMType,omitnil,omitempty" name:"DRMType"`

	// The tracks to encrypt. Valid values: AUDIO, SD, HD, UHD1, UHD2. You can choose only one video track (SD, HD, UHD1, or UHD2).
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMTracks *string `json:"DRMTracks,omitnil,omitempty" name:"DRMTracks"`
}

type CreateLiveTranscodeTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template name, such as “900p”. This can be only a combination of letters and digits.
	// Length limit:
	//   Standard transcoding: 1-10 characters
	//   Top speed codec transcoding: 3-10 characters
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Video bitrate in Kbps. Value range: 100-8000.
	// Note: the transcoding template requires that the bitrate be unique. Therefore, the final saved bitrate may be different from the input bitrate.
	VideoBitrate *int64 `json:"VideoBitrate,omitnil,omitempty" name:"VideoBitrate"`

	// Audio codec. Default value: aac.
	// Note: this parameter is unsupported now.
	Acodec *string `json:"Acodec,omitnil,omitempty" name:"Acodec"`

	// Audio bitrate. Default value: 0.
	// Value range: 0-500.
	AudioBitrate *int64 `json:"AudioBitrate,omitnil,omitempty" name:"AudioBitrate"`

	// Video codec. Valid values: h264, h265, origin (default)
	// 
	// origin: original codec as the output codec
	Vcodec *string `json:"Vcodec,omitnil,omitempty" name:"Vcodec"`

	// Template description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Whether to keep the video. 0: no; 1: yes. Default value: 1.
	NeedVideo *int64 `json:"NeedVideo,omitnil,omitempty" name:"NeedVideo"`

	// Width. Default value: 0.
	// Value range: 0-3000
	// It must be a multiple of 2. The original width is 0.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Whether to keep the audio. 0: no; 1: yes. Default value: 1.
	NeedAudio *int64 `json:"NeedAudio,omitnil,omitempty" name:"NeedAudio"`

	// Height. Default value: 0
	// Value range: 0-3000
	// The value must be a multiple of 2. The original height is `0`.
	// This parameter is required for a top speed codec template (when `AiTransCode` is `1`).
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Frame rate. Default value: 0.
	// Value range: 0-60
	Fps *int64 `json:"Fps,omitnil,omitempty" name:"Fps"`

	// Keyframe interval in seconds. Default value: original interval
	// Value range: 2-6
	Gop *int64 `json:"Gop,omitnil,omitempty" name:"Gop"`

	// Rotation angle. Default value: 0.
	// Valid values: 0, 90, 180, 270
	Rotate *int64 `json:"Rotate,omitnil,omitempty" name:"Rotate"`

	// Encoding quality:
	// baseline/main/high. Default value: baseline.
	Profile *string `json:"Profile,omitnil,omitempty" name:"Profile"`

	// Whether to use the original bitrate when the set bitrate is larger than the original bitrate.
	// 0: no, 1: yes
	// Default value: 0.
	BitrateToOrig *int64 `json:"BitrateToOrig,omitnil,omitempty" name:"BitrateToOrig"`

	// Whether to use the original height when the set height is higher than the original height.
	// 0: no, 1: yes
	// Default value: 0.
	HeightToOrig *int64 `json:"HeightToOrig,omitnil,omitempty" name:"HeightToOrig"`

	// Whether to use the original frame rate when the set frame rate is larger than the original frame rate.
	// 0: no, 1: yes
	// Default value: 0.
	FpsToOrig *int64 `json:"FpsToOrig,omitnil,omitempty" name:"FpsToOrig"`

	// Whether it is a top speed codec template. 0: no, 1: yes. Default value: 0.
	AiTransCode *int64 `json:"AiTransCode,omitnil,omitempty" name:"AiTransCode"`

	// Bitrate compression ratio of top speed codec video.
	// Target bitrate of top speed code = VideoBitrate * (1-AdaptBitratePercent)
	// 
	// Value range: 0.0-0.5.
	AdaptBitratePercent *float64 `json:"AdaptBitratePercent,omitnil,omitempty" name:"AdaptBitratePercent"`

	// Whether to use the short side as the video height. 0: no, 1: yes. Default value: 0.
	ShortEdgeAsHeight *int64 `json:"ShortEdgeAsHeight,omitnil,omitempty" name:"ShortEdgeAsHeight"`

	// The DRM encryption type. Valid values: fairplay, normalaes, widevine.
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMType *string `json:"DRMType,omitnil,omitempty" name:"DRMType"`

	// The tracks to encrypt. Valid values: AUDIO, SD, HD, UHD1, UHD2. You can choose only one video track (SD, HD, UHD1, or UHD2).
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMTracks *string `json:"DRMTracks,omitnil,omitempty" name:"DRMTracks"`
}

func (r *CreateLiveTranscodeTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTranscodeTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateName")
	delete(f, "VideoBitrate")
	delete(f, "Acodec")
	delete(f, "AudioBitrate")
	delete(f, "Vcodec")
	delete(f, "Description")
	delete(f, "NeedVideo")
	delete(f, "Width")
	delete(f, "NeedAudio")
	delete(f, "Height")
	delete(f, "Fps")
	delete(f, "Gop")
	delete(f, "Rotate")
	delete(f, "Profile")
	delete(f, "BitrateToOrig")
	delete(f, "HeightToOrig")
	delete(f, "FpsToOrig")
	delete(f, "AiTransCode")
	delete(f, "AdaptBitratePercent")
	delete(f, "ShortEdgeAsHeight")
	delete(f, "DRMType")
	delete(f, "DRMTracks")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveTranscodeTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveTranscodeTemplateResponseParams struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveTranscodeTemplateResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveTranscodeTemplateResponseParams `json:"Response"`
}

func (r *CreateLiveTranscodeTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveTranscodeTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveWatermarkRuleRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Watermark ID, which is the `WatermarkId` returned by the [AddLiveWatermark](https://intl.cloud.tencent.com/document/product/267/30154?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type CreateLiveWatermarkRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Watermark ID, which is the `WatermarkId` returned by the [AddLiveWatermark](https://intl.cloud.tencent.com/document/product/267/30154?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *CreateLiveWatermarkRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveWatermarkRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateLiveWatermarkRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateLiveWatermarkRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateLiveWatermarkRuleResponse struct {
	*tchttp.BaseResponse
	Response *CreateLiveWatermarkRuleResponseParams `json:"Response"`
}

func (r *CreateLiveWatermarkRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateLiveWatermarkRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateRecordTaskRequestParams struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Recording end time in UNIX timestamp format. `EndTime` should be later than `StartTime` and the current time, and the duration between `EndTime` and `StartTime` is up to 24 hours.
	EndTime *uint64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Recording start time in UNIX timestamp format. Leaving this parameter empty means starting recording now. `StartTime` cannot be later than the current time plus 6 days.
	StartTime *uint64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// Push type. Default value: 0. Valid values:
	// 0: LVB push.
	// 1: mixed stream, i.e., A + B = C mixed stream.
	StreamType *uint64 `json:"StreamType,omitnil,omitempty" name:"StreamType"`

	// Recording template ID, which is the returned value of `CreateLiveRecordTemplate`. If this parameter is left empty or incorrect, the stream will be recorded in HLS format and retained permanently by default.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Extension field which is not defined now. It is empty by default.
	Extension *string `json:"Extension,omitnil,omitempty" name:"Extension"`
}

type CreateRecordTaskRequest struct {
	*tchttp.BaseRequest
	
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Recording end time in UNIX timestamp format. `EndTime` should be later than `StartTime` and the current time, and the duration between `EndTime` and `StartTime` is up to 24 hours.
	EndTime *uint64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Recording start time in UNIX timestamp format. Leaving this parameter empty means starting recording now. `StartTime` cannot be later than the current time plus 6 days.
	StartTime *uint64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// Push type. Default value: 0. Valid values:
	// 0: LVB push.
	// 1: mixed stream, i.e., A + B = C mixed stream.
	StreamType *uint64 `json:"StreamType,omitnil,omitempty" name:"StreamType"`

	// Recording template ID, which is the returned value of `CreateLiveRecordTemplate`. If this parameter is left empty or incorrect, the stream will be recorded in HLS format and retained permanently by default.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Extension field which is not defined now. It is empty by default.
	Extension *string `json:"Extension,omitnil,omitempty" name:"Extension"`
}

func (r *CreateRecordTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateRecordTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StreamName")
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "EndTime")
	delete(f, "StartTime")
	delete(f, "StreamType")
	delete(f, "TemplateId")
	delete(f, "Extension")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateRecordTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateRecordTaskResponseParams struct {
	// A globally unique task ID. If `TaskId` is returned, the recording task has been successfully created.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateRecordTaskResponse struct {
	*tchttp.BaseResponse
	Response *CreateRecordTaskResponseParams `json:"Response"`
}

func (r *CreateRecordTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateRecordTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateScreenshotTaskRequestParams struct {
	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The push domain.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The task end time, which must be a Unix timestamp and later than `StartTime` and the current time. The end time and start time cannot be more than 24 hours apart.
	EndTime *uint64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The ID of the screencapturing template, which is returned by `CreateLiveSnapshotTemplate`. If an incorrect template ID is passed in, the screencapturing task will fail.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The task start time, which must be a Unix timestamp and cannot be later than six days from the current time. If you do not specify this parameter, the task will start immediately.
	StartTime *uint64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The publishing type. Valid values:
	// `0` (default): Live stream
	// `1`: Mixed stream
	StreamType *uint64 `json:"StreamType,omitnil,omitempty" name:"StreamType"`

	// An extension field, which is not defined currently and is empty by default.
	Extension *string `json:"Extension,omitnil,omitempty" name:"Extension"`
}

type CreateScreenshotTaskRequest struct {
	*tchttp.BaseRequest
	
	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The push domain.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The task end time, which must be a Unix timestamp and later than `StartTime` and the current time. The end time and start time cannot be more than 24 hours apart.
	EndTime *uint64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The ID of the screencapturing template, which is returned by `CreateLiveSnapshotTemplate`. If an incorrect template ID is passed in, the screencapturing task will fail.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The task start time, which must be a Unix timestamp and cannot be later than six days from the current time. If you do not specify this parameter, the task will start immediately.
	StartTime *uint64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The publishing type. Valid values:
	// `0` (default): Live stream
	// `1`: Mixed stream
	StreamType *uint64 `json:"StreamType,omitnil,omitempty" name:"StreamType"`

	// An extension field, which is not defined currently and is empty by default.
	Extension *string `json:"Extension,omitnil,omitempty" name:"Extension"`
}

func (r *CreateScreenshotTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateScreenshotTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StreamName")
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "EndTime")
	delete(f, "TemplateId")
	delete(f, "StartTime")
	delete(f, "StreamType")
	delete(f, "Extension")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "CreateScreenshotTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type CreateScreenshotTaskResponseParams struct {
	// A unique task ID. If this parameter is returned, the screencapturing task is created successfully.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type CreateScreenshotTaskResponse struct {
	*tchttp.BaseResponse
	Response *CreateScreenshotTaskResponseParams `json:"Response"`
}

func (r *CreateScreenshotTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *CreateScreenshotTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type DayStreamPlayInfo struct {
	// Data point in time in the format of `yyyy-mm-dd HH:MM:SS`.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Bandwidth in Mbps.
	Bandwidth *float64 `json:"Bandwidth,omitnil,omitempty" name:"Bandwidth"`

	// Traffic in MB.
	Flux *float64 `json:"Flux,omitnil,omitempty" name:"Flux"`

	// Number of requests.
	Request *uint64 `json:"Request,omitnil,omitempty" name:"Request"`

	// Number of online viewers.
	Online *uint64 `json:"Online,omitnil,omitempty" name:"Online"`
}

type DelayInfo struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the 
	//  `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Delay time in seconds.
	DelayInterval *uint64 `json:"DelayInterval,omitnil,omitempty" name:"DelayInterval"`

	// Creation time in UTC time.
	// Note: the difference between UTC time and Beijing time is 8 hours.
	// Example: 2019-06-18T12:00:00Z (i.e., June 18, 2019 20:00:00 Beijing time).
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// Expiration time in UTC time.
	// Note: the difference between UTC time and Beijing time is 8 hours.
	// Example: 2019-06-18T12:00:00Z (i.e., June 18, 2019 20:00:00 Beijing time).
	ExpireTime *string `json:"ExpireTime,omitnil,omitempty" name:"ExpireTime"`

	// Current status:
	// -1: expired.
	// 1: in effect.
	Status *int64 `json:"Status,omitnil,omitempty" name:"Status"`
}

// Predefined struct for user
type DeleteLiveCallbackRuleRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`
}

type DeleteLiveCallbackRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`
}

func (r *DeleteLiveCallbackRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveCallbackRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveCallbackRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveCallbackRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveCallbackRuleResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveCallbackRuleResponseParams `json:"Response"`
}

func (r *DeleteLiveCallbackRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveCallbackRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveCallbackTemplateRequestParams struct {
	// Template ID.
	// 1. Get the template ID in the returned value of the [CreateLiveCallbackTemplate](https://intl.cloud.tencent.com/document/product/267/32637?from_cn_redirect=1) API call.
	// 2. You can query the list of created templates through the [DescribeLiveCallbackTemplates](https://intl.cloud.tencent.com/document/product/267/32632?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DeleteLiveCallbackTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	// 1. Get the template ID in the returned value of the [CreateLiveCallbackTemplate](https://intl.cloud.tencent.com/document/product/267/32637?from_cn_redirect=1) API call.
	// 2. You can query the list of created templates through the [DescribeLiveCallbackTemplates](https://intl.cloud.tencent.com/document/product/267/32632?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DeleteLiveCallbackTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveCallbackTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveCallbackTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveCallbackTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveCallbackTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveCallbackTemplateResponseParams `json:"Response"`
}

func (r *DeleteLiveCallbackTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveCallbackTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveDomainRequestParams struct {
	// Domain name to be deleted.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Type. 0: push, 1: playback.
	DomainType *uint64 `json:"DomainType,omitnil,omitempty" name:"DomainType"`
}

type DeleteLiveDomainRequest struct {
	*tchttp.BaseRequest
	
	// Domain name to be deleted.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Type. 0: push, 1: playback.
	DomainType *uint64 `json:"DomainType,omitnil,omitempty" name:"DomainType"`
}

func (r *DeleteLiveDomainRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveDomainRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "DomainType")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveDomainRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveDomainResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveDomainResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveDomainResponseParams `json:"Response"`
}

func (r *DeleteLiveDomainResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveDomainResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLivePullStreamTaskRequestParams struct {
	// The task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`
}

type DeleteLivePullStreamTaskRequest struct {
	*tchttp.BaseRequest
	
	// The task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`
}

func (r *DeleteLivePullStreamTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLivePullStreamTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TaskId")
	delete(f, "Operator")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLivePullStreamTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLivePullStreamTaskResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLivePullStreamTaskResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLivePullStreamTaskResponseParams `json:"Response"`
}

func (r *DeleteLivePullStreamTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLivePullStreamTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveRecordRequestParams struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Task ID returned by the `CreateLiveRecord` API.
	TaskId *int64 `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

type DeleteLiveRecordRequest struct {
	*tchttp.BaseRequest
	
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Task ID returned by the `CreateLiveRecord` API.
	TaskId *int64 `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

func (r *DeleteLiveRecordRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveRecordRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StreamName")
	delete(f, "TaskId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveRecordRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveRecordResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveRecordResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveRecordResponseParams `json:"Response"`
}

func (r *DeleteLiveRecordResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveRecordResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveRecordRuleRequestParams struct {
	// Push domain name.
	// Domain name+AppName+StreamName uniquely identifies a single transcoding rule. If you need to delete it, strong match is required. For example, even if AppName is blank, you need to pass in a blank string to make a strong match.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	// Domain name+AppName+StreamName uniquely identifies a single transcoding rule. If you need to delete it, strong match is required. For example, even if AppName is blank, you need to pass in a blank string to make a strong match.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	// Domain name+AppName+StreamName uniquely identifies a single transcoding rule. If you need to delete it, strong match is required. For example, even if AppName is blank, you need to pass in a blank string to make a strong match.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DeleteLiveRecordRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	// Domain name+AppName+StreamName uniquely identifies a single transcoding rule. If you need to delete it, strong match is required. For example, even if AppName is blank, you need to pass in a blank string to make a strong match.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	// Domain name+AppName+StreamName uniquely identifies a single transcoding rule. If you need to delete it, strong match is required. For example, even if AppName is blank, you need to pass in a blank string to make a strong match.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	// Domain name+AppName+StreamName uniquely identifies a single transcoding rule. If you need to delete it, strong match is required. For example, even if AppName is blank, you need to pass in a blank string to make a strong match.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DeleteLiveRecordRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveRecordRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveRecordRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveRecordRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveRecordRuleResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveRecordRuleResponseParams `json:"Response"`
}

func (r *DeleteLiveRecordRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveRecordRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveRecordTemplateRequestParams struct {
	// Template ID obtained through the `DescribeRecordTemplates` API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DeleteLiveRecordTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID obtained through the `DescribeRecordTemplates` API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DeleteLiveRecordTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveRecordTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveRecordTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveRecordTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveRecordTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveRecordTemplateResponseParams `json:"Response"`
}

func (r *DeleteLiveRecordTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveRecordTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveSnapshotRuleRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DeleteLiveSnapshotRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DeleteLiveSnapshotRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveSnapshotRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveSnapshotRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveSnapshotRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveSnapshotRuleResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveSnapshotRuleResponseParams `json:"Response"`
}

func (r *DeleteLiveSnapshotRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveSnapshotRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveSnapshotTemplateRequestParams struct {
	// Template ID.
	// 1. Get from the returned value of the [CreateLiveSnapshotTemplate](https://intl.cloud.tencent.com/document/product/267/32624?from_cn_redirect=1) API call.
	// 2. You can query the list of created screencapturing templates through the [DescribeLiveSnapshotTemplates](https://intl.cloud.tencent.com/document/product/267/32619?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DeleteLiveSnapshotTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	// 1. Get from the returned value of the [CreateLiveSnapshotTemplate](https://intl.cloud.tencent.com/document/product/267/32624?from_cn_redirect=1) API call.
	// 2. You can query the list of created screencapturing templates through the [DescribeLiveSnapshotTemplates](https://intl.cloud.tencent.com/document/product/267/32619?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DeleteLiveSnapshotTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveSnapshotTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveSnapshotTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveSnapshotTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveSnapshotTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveSnapshotTemplateResponseParams `json:"Response"`
}

func (r *DeleteLiveSnapshotTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveSnapshotTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTimeShiftRuleRequestParams struct {
	// The push domain.
	// `Domain name+AppName+StreamName` uniquely identifies a time shifting rule. To delete a time shifting rule, exact match is required. This means if the `AppName` of a time shifting rule is empty, to delete the rule, you need to pass in an empty string for `AppName`.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which should be the same as `AppName` in the push and playback URLs. The default value is `live`.
	// `Domain name+AppName+StreamName` uniquely identifies a time shifting rule. To delete a time shifting rule, exact match is required. This means if the `AppName` of a time shifting rule is empty, to delete the rule, you need to pass in an empty string for `AppName`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	// `Domain name+AppName+StreamName` uniquely identifies a time shifting rule. To delete a time shifting rule, exact match is required. This means if the `AppName` of a time shifting rule is empty, to delete the rule, you need to pass in an empty string for `AppName`.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DeleteLiveTimeShiftRuleRequest struct {
	*tchttp.BaseRequest
	
	// The push domain.
	// `Domain name+AppName+StreamName` uniquely identifies a time shifting rule. To delete a time shifting rule, exact match is required. This means if the `AppName` of a time shifting rule is empty, to delete the rule, you need to pass in an empty string for `AppName`.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which should be the same as `AppName` in the push and playback URLs. The default value is `live`.
	// `Domain name+AppName+StreamName` uniquely identifies a time shifting rule. To delete a time shifting rule, exact match is required. This means if the `AppName` of a time shifting rule is empty, to delete the rule, you need to pass in an empty string for `AppName`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	// `Domain name+AppName+StreamName` uniquely identifies a time shifting rule. To delete a time shifting rule, exact match is required. This means if the `AppName` of a time shifting rule is empty, to delete the rule, you need to pass in an empty string for `AppName`.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DeleteLiveTimeShiftRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTimeShiftRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveTimeShiftRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTimeShiftRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveTimeShiftRuleResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveTimeShiftRuleResponseParams `json:"Response"`
}

func (r *DeleteLiveTimeShiftRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTimeShiftRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTimeShiftTemplateRequestParams struct {
	// The template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DeleteLiveTimeShiftTemplateRequest struct {
	*tchttp.BaseRequest
	
	// The template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DeleteLiveTimeShiftTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTimeShiftTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveTimeShiftTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTimeShiftTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveTimeShiftTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveTimeShiftTemplateResponseParams `json:"Response"`
}

func (r *DeleteLiveTimeShiftTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTimeShiftTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTranscodeRuleRequestParams struct {
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DeleteLiveTranscodeRuleRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DeleteLiveTranscodeRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTranscodeRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveTranscodeRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTranscodeRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveTranscodeRuleResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveTranscodeRuleResponseParams `json:"Response"`
}

func (r *DeleteLiveTranscodeRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTranscodeRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTranscodeTemplateRequestParams struct {
	// Template ID.
	// 1. Get the template ID in the returned value of the [CreateLiveTranscodeTemplate](https://intl.cloud.tencent.com/document/product/267/32646?from_cn_redirect=1) API call.
	// 2. You can query the list of created templates through the [DescribeLiveTranscodeTemplates](https://intl.cloud.tencent.com/document/product/267/32641?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DeleteLiveTranscodeTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	// 1. Get the template ID in the returned value of the [CreateLiveTranscodeTemplate](https://intl.cloud.tencent.com/document/product/267/32646?from_cn_redirect=1) API call.
	// 2. You can query the list of created templates through the [DescribeLiveTranscodeTemplates](https://intl.cloud.tencent.com/document/product/267/32641?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DeleteLiveTranscodeTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTranscodeTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveTranscodeTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveTranscodeTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveTranscodeTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveTranscodeTemplateResponseParams `json:"Response"`
}

func (r *DeleteLiveTranscodeTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveTranscodeTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveWatermarkRequestParams struct {
	// Watermark ID.
	// Watermark ID obtained in the returned value of the [AddLiveWatermark](https://intl.cloud.tencent.com/document/product/267/30154?from_cn_redirect=1) API call.
	// Watermark ID returned by the `DescribeLiveWatermarks` API.
	WatermarkId *int64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`
}

type DeleteLiveWatermarkRequest struct {
	*tchttp.BaseRequest
	
	// Watermark ID.
	// Watermark ID obtained in the returned value of the [AddLiveWatermark](https://intl.cloud.tencent.com/document/product/267/30154?from_cn_redirect=1) API call.
	// Watermark ID returned by the `DescribeLiveWatermarks` API.
	WatermarkId *int64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`
}

func (r *DeleteLiveWatermarkRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveWatermarkRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "WatermarkId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveWatermarkRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveWatermarkResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveWatermarkResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveWatermarkResponseParams `json:"Response"`
}

func (r *DeleteLiveWatermarkResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveWatermarkResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveWatermarkRuleRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DeleteLiveWatermarkRuleRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DeleteLiveWatermarkRuleRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveWatermarkRuleRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteLiveWatermarkRuleRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteLiveWatermarkRuleResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteLiveWatermarkRuleResponse struct {
	*tchttp.BaseResponse
	Response *DeleteLiveWatermarkRuleResponseParams `json:"Response"`
}

func (r *DeleteLiveWatermarkRuleResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteLiveWatermarkRuleResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteRecordTaskRequestParams struct {
	// Task ID returned by `CreateRecordTask`. The recording task specified by `TaskId` will be deleted.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

type DeleteRecordTaskRequest struct {
	*tchttp.BaseRequest
	
	// Task ID returned by `CreateRecordTask`. The recording task specified by `TaskId` will be deleted.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

func (r *DeleteRecordTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteRecordTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TaskId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DeleteRecordTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DeleteRecordTaskResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DeleteRecordTaskResponse struct {
	*tchttp.BaseResponse
	Response *DeleteRecordTaskResponseParams `json:"Response"`
}

func (r *DeleteRecordTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DeleteRecordTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeAllStreamPlayInfoListRequestParams struct {
	// The query time of the request, supports data query for the last one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	QueryTime *string `json:"QueryTime,omitnil,omitempty" name:"QueryTime"`

	// The playback domains to query. If you leave this empty, all playback domains will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`
}

type DescribeAllStreamPlayInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The query time of the request, supports data query for the last one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	QueryTime *string `json:"QueryTime,omitnil,omitempty" name:"QueryTime"`

	// The playback domains to query. If you leave this empty, all playback domains will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`
}

func (r *DescribeAllStreamPlayInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeAllStreamPlayInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "QueryTime")
	delete(f, "PlayDomains")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeAllStreamPlayInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeAllStreamPlayInfoListResponseParams struct {
	// The time point queried, whose format is the same as that of the corresponding request parameter.
	QueryTime *string `json:"QueryTime,omitnil,omitempty" name:"QueryTime"`

	// The playback data.
	DataInfoList []*MonitorStreamPlayInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeAllStreamPlayInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeAllStreamPlayInfoListResponseParams `json:"Response"`
}

func (r *DescribeAllStreamPlayInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeAllStreamPlayInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeBillBandwidthAndFluxListRequestParams struct {
	// The start time of the request, supports data query for the last three years, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three years, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// LVB playback domain name. If this parameter is left empty, full data will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Valid values:
	// Mainland: query data for Mainland China,
	// Oversea: query data for regions outside Mainland China,
	// Default: query data for all regions.
	// Note: LEB only supports querying data for all regions.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Data granularity. Valid values:
	// 5: 5-minute granularity (the query time span should be within 1 day),
	// 60: 1-hour granularity (the query time span should be within one month),
	// 1440: 1-day granularity (the query time span should be within one month).
	// Default value: 5.
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`

	// Service name. Valid values: LVB, LEB. The sum of LVB and LEB usage will be returned if this parameter is left empty.
	ServiceName *string `json:"ServiceName,omitnil,omitempty" name:"ServiceName"`

	// Region. Valid values:
	// China Mainland
	// Asia Pacific I
	// Asia Pacific II
	// Asia Pacific III
	// Europe
	// North America
	// South America
	// Middle East
	// Africa
	RegionNames []*string `json:"RegionNames,omitnil,omitempty" name:"RegionNames"`
}

type DescribeBillBandwidthAndFluxListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last three years, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three years, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// LVB playback domain name. If this parameter is left empty, full data will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Valid values:
	// Mainland: query data for Mainland China,
	// Oversea: query data for regions outside Mainland China,
	// Default: query data for all regions.
	// Note: LEB only supports querying data for all regions.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Data granularity. Valid values:
	// 5: 5-minute granularity (the query time span should be within 1 day),
	// 60: 1-hour granularity (the query time span should be within one month),
	// 1440: 1-day granularity (the query time span should be within one month).
	// Default value: 5.
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`

	// Service name. Valid values: LVB, LEB. The sum of LVB and LEB usage will be returned if this parameter is left empty.
	ServiceName *string `json:"ServiceName,omitnil,omitempty" name:"ServiceName"`

	// Region. Valid values:
	// China Mainland
	// Asia Pacific I
	// Asia Pacific II
	// Asia Pacific III
	// Europe
	// North America
	// South America
	// Middle East
	// Africa
	RegionNames []*string `json:"RegionNames,omitnil,omitempty" name:"RegionNames"`
}

func (r *DescribeBillBandwidthAndFluxListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeBillBandwidthAndFluxListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PlayDomains")
	delete(f, "MainlandOrOversea")
	delete(f, "Granularity")
	delete(f, "ServiceName")
	delete(f, "RegionNames")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeBillBandwidthAndFluxListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeBillBandwidthAndFluxListResponseParams struct {
	// Time point of peak bandwidth value in the format of `yyyy-mm-dd HH:MM:SS`.
	PeakBandwidthTime *string `json:"PeakBandwidthTime,omitnil,omitempty" name:"PeakBandwidthTime"`

	// Peak bandwidth in Mbps.
	PeakBandwidth *float64 `json:"PeakBandwidth,omitnil,omitempty" name:"PeakBandwidth"`

	// Time point of 95th percentile bandwidth value in the format of `yyyy-mm-dd HH:MM:SS`.
	P95PeakBandwidthTime *string `json:"P95PeakBandwidthTime,omitnil,omitempty" name:"P95PeakBandwidthTime"`

	// 95th percentile bandwidth in Mbps.
	P95PeakBandwidth *float64 `json:"P95PeakBandwidth,omitnil,omitempty" name:"P95PeakBandwidth"`

	// Total traffic in MB.
	SumFlux *float64 `json:"SumFlux,omitnil,omitempty" name:"SumFlux"`

	// Detailed data information.
	DataInfoList []*BillDataInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeBillBandwidthAndFluxListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeBillBandwidthAndFluxListResponseParams `json:"Response"`
}

func (r *DescribeBillBandwidthAndFluxListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeBillBandwidthAndFluxListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeConcurrentRecordStreamNumRequestParams struct {
	// Live streaming type. SlowLive: LCB.
	// NormalLive: LVB.
	LiveType *string `json:"LiveType,omitnil,omitempty" name:"LiveType"`

	// The start time of the request, supports data query for the last six months, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last six months, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Playback domain name list. If this parameter is left empty, full data will be queried.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`
}

type DescribeConcurrentRecordStreamNumRequest struct {
	*tchttp.BaseRequest
	
	// Live streaming type. SlowLive: LCB.
	// NormalLive: LVB.
	LiveType *string `json:"LiveType,omitnil,omitempty" name:"LiveType"`

	// The start time of the request, supports data query for the last six months, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last six months, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Playback domain name list. If this parameter is left empty, full data will be queried.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`
}

func (r *DescribeConcurrentRecordStreamNumRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeConcurrentRecordStreamNumRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "LiveType")
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "MainlandOrOversea")
	delete(f, "PushDomains")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeConcurrentRecordStreamNumRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeConcurrentRecordStreamNumResponseParams struct {
	// Statistics list.
	DataInfoList []*ConcurrentRecordStreamNum `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeConcurrentRecordStreamNumResponse struct {
	*tchttp.BaseResponse
	Response *DescribeConcurrentRecordStreamNumResponseParams `json:"Response"`
}

func (r *DescribeConcurrentRecordStreamNumResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeConcurrentRecordStreamNumResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeDeliverBandwidthListRequestParams struct {
	// The start time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed a month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed a month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`
}

type DescribeDeliverBandwidthListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed a month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed a month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`
}

func (r *DescribeDeliverBandwidthListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeDeliverBandwidthListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeDeliverBandwidthListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeDeliverBandwidthListResponseParams struct {
	// Billable bandwidth of live stream relaying.
	DataInfoList []*BandwidthInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeDeliverBandwidthListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeDeliverBandwidthListResponseParams `json:"Response"`
}

func (r *DescribeDeliverBandwidthListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeDeliverBandwidthListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeGroupProIspPlayInfoListRequestParams struct {
	// The start time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name. If this parameter is left empty, full data will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// District list. If this parameter is left empty, data for all districts will be returned.
	ProvinceNames []*string `json:"ProvinceNames,omitnil,omitempty" name:"ProvinceNames"`

	// ISP list. If this parameter is left empty, data of all ISPs will be returned.
	IspNames []*string `json:"IspNames,omitnil,omitempty" name:"IspNames"`

	// Within or outside Mainland China. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`
}

type DescribeGroupProIspPlayInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name. If this parameter is left empty, full data will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// District list. If this parameter is left empty, data for all districts will be returned.
	ProvinceNames []*string `json:"ProvinceNames,omitnil,omitempty" name:"ProvinceNames"`

	// ISP list. If this parameter is left empty, data of all ISPs will be returned.
	IspNames []*string `json:"IspNames,omitnil,omitempty" name:"IspNames"`

	// Within or outside Mainland China. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`
}

func (r *DescribeGroupProIspPlayInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeGroupProIspPlayInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PlayDomains")
	delete(f, "ProvinceNames")
	delete(f, "IspNames")
	delete(f, "MainlandOrOversea")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeGroupProIspPlayInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeGroupProIspPlayInfoListResponseParams struct {
	// Data content.
	DataInfoList []*GroupProIspDataInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeGroupProIspPlayInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeGroupProIspPlayInfoListResponseParams `json:"Response"`
}

func (r *DescribeGroupProIspPlayInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeGroupProIspPlayInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeHttpStatusInfoListRequestParams struct {
	// The start time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name list.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`
}

type DescribeHttpStatusInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name list.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`
}

func (r *DescribeHttpStatusInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeHttpStatusInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PlayDomains")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeHttpStatusInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeHttpStatusInfoListResponseParams struct {
	// Playback status code list.
	DataInfoList []*HttpStatusData `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeHttpStatusInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeHttpStatusInfoListResponseParams `json:"Response"`
}

func (r *DescribeHttpStatusInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeHttpStatusInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCallbackRulesRequestParams struct {

}

type DescribeLiveCallbackRulesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveCallbackRulesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCallbackRulesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveCallbackRulesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCallbackRulesResponseParams struct {
	// Rule information list.
	Rules []*CallBackRuleInfo `json:"Rules,omitnil,omitempty" name:"Rules"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveCallbackRulesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveCallbackRulesResponseParams `json:"Response"`
}

func (r *DescribeLiveCallbackRulesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCallbackRulesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCallbackTemplateRequestParams struct {
	// Template ID.
	// 1. Get the template ID in the returned value of the [CreateLiveCallbackTemplate](https://intl.cloud.tencent.com/document/product/267/32637?from_cn_redirect=1) API call.
	// 2. You can query the list of created templates through the [DescribeLiveCallbackTemplates](https://intl.cloud.tencent.com/document/product/267/32632?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DescribeLiveCallbackTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	// 1. Get the template ID in the returned value of the [CreateLiveCallbackTemplate](https://intl.cloud.tencent.com/document/product/267/32637?from_cn_redirect=1) API call.
	// 2. You can query the list of created templates through the [DescribeLiveCallbackTemplates](https://intl.cloud.tencent.com/document/product/267/32632?from_cn_redirect=1) API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DescribeLiveCallbackTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCallbackTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveCallbackTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCallbackTemplateResponseParams struct {
	// Callback template information.
	Template *CallBackTemplateInfo `json:"Template,omitnil,omitempty" name:"Template"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveCallbackTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveCallbackTemplateResponseParams `json:"Response"`
}

func (r *DescribeLiveCallbackTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCallbackTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCallbackTemplatesRequestParams struct {

}

type DescribeLiveCallbackTemplatesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveCallbackTemplatesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCallbackTemplatesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveCallbackTemplatesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCallbackTemplatesResponseParams struct {
	// Template information list.
	Templates []*CallBackTemplateInfo `json:"Templates,omitnil,omitempty" name:"Templates"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveCallbackTemplatesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveCallbackTemplatesResponseParams `json:"Response"`
}

func (r *DescribeLiveCallbackTemplatesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCallbackTemplatesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCertRequestParams struct {
	// Certificate ID obtained through the `DescribeLiveCerts` API.
	CertId *int64 `json:"CertId,omitnil,omitempty" name:"CertId"`
}

type DescribeLiveCertRequest struct {
	*tchttp.BaseRequest
	
	// Certificate ID obtained through the `DescribeLiveCerts` API.
	CertId *int64 `json:"CertId,omitnil,omitempty" name:"CertId"`
}

func (r *DescribeLiveCertRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCertRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "CertId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveCertRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCertResponseParams struct {
	// Certificate information.
	CertInfo *CertInfo `json:"CertInfo,omitnil,omitempty" name:"CertInfo"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveCertResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveCertResponseParams `json:"Response"`
}

func (r *DescribeLiveCertResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCertResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCertsRequestParams struct {

}

type DescribeLiveCertsRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveCertsRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCertsRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveCertsRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveCertsResponseParams struct {
	// Certificate information list.
	CertInfoSet []*CertInfo `json:"CertInfoSet,omitnil,omitempty" name:"CertInfoSet"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveCertsResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveCertsResponseParams `json:"Response"`
}

func (r *DescribeLiveCertsResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveCertsResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDelayInfoListRequestParams struct {

}

type DescribeLiveDelayInfoListRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveDelayInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDelayInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveDelayInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDelayInfoListResponseParams struct {
	// Delayed playback information list.
	DelayInfoList []*DelayInfo `json:"DelayInfoList,omitnil,omitempty" name:"DelayInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveDelayInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveDelayInfoListResponseParams `json:"Response"`
}

func (r *DescribeLiveDelayInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDelayInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainCertBindingsRequestParams struct {
	// The keyword to use to search for domains.
	DomainSearch *string `json:"DomainSearch,omitnil,omitempty" name:"DomainSearch"`

	// The number of records to skip before starting to return any results. 0 means to start from the first record and is the default.
	Offset *int64 `json:"Offset,omitnil,omitempty" name:"Offset"`

	// The maximum number of records to return. The default is 50.
	// If this parameter is not specified, up to 50 records will be returned.
	Length *int64 `json:"Length,omitnil,omitempty" name:"Length"`

	// The name of a particular domain to query.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Valid values:
	// ExpireTimeAsc: Sort the records by certificate expiration time in ascending order.
	// ExpireTimeDesc: Sort the records by certificate expiration time in descending order.
	OrderBy *string `json:"OrderBy,omitnil,omitempty" name:"OrderBy"`
}

type DescribeLiveDomainCertBindingsRequest struct {
	*tchttp.BaseRequest
	
	// The keyword to use to search for domains.
	DomainSearch *string `json:"DomainSearch,omitnil,omitempty" name:"DomainSearch"`

	// The number of records to skip before starting to return any results. 0 means to start from the first record and is the default.
	Offset *int64 `json:"Offset,omitnil,omitempty" name:"Offset"`

	// The maximum number of records to return. The default is 50.
	// If this parameter is not specified, up to 50 records will be returned.
	Length *int64 `json:"Length,omitnil,omitempty" name:"Length"`

	// The name of a particular domain to query.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Valid values:
	// ExpireTimeAsc: Sort the records by certificate expiration time in ascending order.
	// ExpireTimeDesc: Sort the records by certificate expiration time in descending order.
	OrderBy *string `json:"OrderBy,omitnil,omitempty" name:"OrderBy"`
}

func (r *DescribeLiveDomainCertBindingsRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainCertBindingsRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainSearch")
	delete(f, "Offset")
	delete(f, "Length")
	delete(f, "DomainName")
	delete(f, "OrderBy")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveDomainCertBindingsRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainCertBindingsResponseParams struct {
	// The information of domains that meet the query criteria.
	LiveDomainCertBindings []*LiveDomainCertBindings `json:"LiveDomainCertBindings,omitnil,omitempty" name:"LiveDomainCertBindings"`

	// The number of records returned, which is needed for pagination.
	TotalNum *int64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveDomainCertBindingsResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveDomainCertBindingsResponseParams `json:"Response"`
}

func (r *DescribeLiveDomainCertBindingsResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainCertBindingsResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainCertRequestParams struct {
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type DescribeLiveDomainCertRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

func (r *DescribeLiveDomainCertRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainCertRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveDomainCertRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainCertResponseParams struct {
	// Certificate information.
	DomainCertInfo *DomainCertInfo `json:"DomainCertInfo,omitnil,omitempty" name:"DomainCertInfo"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveDomainCertResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveDomainCertResponseParams `json:"Response"`
}

func (r *DescribeLiveDomainCertResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainCertResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainRefererRequestParams struct {
	// Playback domain name
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type DescribeLiveDomainRefererRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

func (r *DescribeLiveDomainRefererRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainRefererRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveDomainRefererRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainRefererResponseParams struct {
	// Referer allowlist/blocklist configuration of a domain name
	RefererAuthConfig *RefererAuthConfig `json:"RefererAuthConfig,omitnil,omitempty" name:"RefererAuthConfig"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveDomainRefererResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveDomainRefererResponseParams `json:"Response"`
}

func (r *DescribeLiveDomainRefererResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainRefererResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainRequestParams struct {
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type DescribeLiveDomainRequest struct {
	*tchttp.BaseRequest
	
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

func (r *DescribeLiveDomainRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveDomainRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainResponseParams struct {
	// Domain name information.
	// Note: this field may return `null`, indicating that no valid value is obtained.
	DomainInfo *DomainInfo `json:"DomainInfo,omitnil,omitempty" name:"DomainInfo"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveDomainResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveDomainResponseParams `json:"Response"`
}

func (r *DescribeLiveDomainResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainsRequestParams struct {
	// Filter by domain name status. 0: disabled, 1: enabled.
	DomainStatus *uint64 `json:"DomainStatus,omitnil,omitempty" name:"DomainStatus"`

	// Filter by domain name type. 0: push. 1: playback
	DomainType *uint64 `json:"DomainType,omitnil,omitempty" name:"DomainType"`

	// Number of entries per page. Value range: 10-100. Default value: 10.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Page number to get. Value range: 1-100000. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// 0: LVB, 1: LCB. Default value: 0.
	IsDelayLive *uint64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// Domain name prefix.
	DomainPrefix *string `json:"DomainPrefix,omitnil,omitempty" name:"DomainPrefix"`

	// Playback region. This parameter is valid only when `DomainType` is set to `1`.
	// `1`: Chinese mainland
	// `2`: global
	// `3`: outside Chinese mainland
	PlayType *uint64 `json:"PlayType,omitnil,omitempty" name:"PlayType"`
}

type DescribeLiveDomainsRequest struct {
	*tchttp.BaseRequest
	
	// Filter by domain name status. 0: disabled, 1: enabled.
	DomainStatus *uint64 `json:"DomainStatus,omitnil,omitempty" name:"DomainStatus"`

	// Filter by domain name type. 0: push. 1: playback
	DomainType *uint64 `json:"DomainType,omitnil,omitempty" name:"DomainType"`

	// Number of entries per page. Value range: 10-100. Default value: 10.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Page number to get. Value range: 1-100000. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// 0: LVB, 1: LCB. Default value: 0.
	IsDelayLive *uint64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// Domain name prefix.
	DomainPrefix *string `json:"DomainPrefix,omitnil,omitempty" name:"DomainPrefix"`

	// Playback region. This parameter is valid only when `DomainType` is set to `1`.
	// `1`: Chinese mainland
	// `2`: global
	// `3`: outside Chinese mainland
	PlayType *uint64 `json:"PlayType,omitnil,omitempty" name:"PlayType"`
}

func (r *DescribeLiveDomainsRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainsRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainStatus")
	delete(f, "DomainType")
	delete(f, "PageSize")
	delete(f, "PageNum")
	delete(f, "IsDelayLive")
	delete(f, "DomainPrefix")
	delete(f, "PlayType")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveDomainsRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveDomainsResponseParams struct {
	// Total number of results.
	AllCount *uint64 `json:"AllCount,omitnil,omitempty" name:"AllCount"`

	// List of domain name details.
	DomainList []*DomainInfo `json:"DomainList,omitnil,omitempty" name:"DomainList"`

	// The number of domain names that can be added
	// Note: this field may return `null`, indicating that no valid values can be obtained.
	CreateLimitCount *int64 `json:"CreateLimitCount,omitnil,omitempty" name:"CreateLimitCount"`

	// The number of domains accelerated in the Chinese mainland, globally, and outside the Chinese mainland respectively.
	// Note: This field may return null, indicating that no valid values can be obtained.
	PlayTypeCount []*int64 `json:"PlayTypeCount,omitnil,omitempty" name:"PlayTypeCount"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveDomainsResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveDomainsResponseParams `json:"Response"`
}

func (r *DescribeLiveDomainsResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveDomainsResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveForbidStreamListRequestParams struct {
	// Page number to get. Default value: 1.
	PageNum *int64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Maximum value: 100. 
	// Value: any integer between 1 and 100.
	// Default value: 10.
	PageSize *int64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Stream name for query
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DescribeLiveForbidStreamListRequest struct {
	*tchttp.BaseRequest
	
	// Page number to get. Default value: 1.
	PageNum *int64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Maximum value: 100. 
	// Value: any integer between 1 and 100.
	// Default value: 10.
	PageSize *int64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Stream name for query
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DescribeLiveForbidStreamListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveForbidStreamListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveForbidStreamListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveForbidStreamListResponseParams struct {
	// Total number of eligible ones.
	TotalNum *int64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of pages.
	TotalPage *int64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// Page number.
	PageNum *int64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries displayed per page.
	PageSize *int64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// List of forbidden streams.
	ForbidStreamList []*ForbidStreamInfo `json:"ForbidStreamList,omitnil,omitempty" name:"ForbidStreamList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveForbidStreamListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveForbidStreamListResponseParams `json:"Response"`
}

func (r *DescribeLiveForbidStreamListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveForbidStreamListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLivePlayAuthKeyRequestParams struct {
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type DescribeLivePlayAuthKeyRequest struct {
	*tchttp.BaseRequest
	
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

func (r *DescribeLivePlayAuthKeyRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLivePlayAuthKeyRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLivePlayAuthKeyRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLivePlayAuthKeyResponseParams struct {
	// Playback authentication key information.
	PlayAuthKeyInfo *PlayAuthKeyInfo `json:"PlayAuthKeyInfo,omitnil,omitempty" name:"PlayAuthKeyInfo"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLivePlayAuthKeyResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLivePlayAuthKeyResponseParams `json:"Response"`
}

func (r *DescribeLivePlayAuthKeyResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLivePlayAuthKeyResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLivePullStreamTasksRequestParams struct {
	// The task ID. 
	// A task ID is returned by the `CreateLivePullStreamTask` API.
	// If you do not pass this parameter, all tasks will be returned, sorted by last updated time in descending order.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The number of page to start from. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// The maximum number of records per page. Default value: 10.
	// Valid values: Any integer between 1 and 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`
}

type DescribeLivePullStreamTasksRequest struct {
	*tchttp.BaseRequest
	
	// The task ID. 
	// A task ID is returned by the `CreateLivePullStreamTask` API.
	// If you do not pass this parameter, all tasks will be returned, sorted by last updated time in descending order.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The number of page to start from. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// The maximum number of records per page. Default value: 10.
	// Valid values: Any integer between 1 and 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`
}

func (r *DescribeLivePullStreamTasksRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLivePullStreamTasksRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TaskId")
	delete(f, "PageNum")
	delete(f, "PageSize")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLivePullStreamTasksRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLivePullStreamTasksResponseParams struct {
	// The information of stream pulling tasks.
	TaskInfos []*PullStreamTaskInfo `json:"TaskInfos,omitnil,omitempty" name:"TaskInfos"`

	// The page number.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// The number of records per page.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// The total number of records.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// The total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// The maximum number of tasks allowed.
	LimitTaskNum *uint64 `json:"LimitTaskNum,omitnil,omitempty" name:"LimitTaskNum"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLivePullStreamTasksResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLivePullStreamTasksResponseParams `json:"Response"`
}

func (r *DescribeLivePullStreamTasksResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLivePullStreamTasksResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLivePushAuthKeyRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type DescribeLivePushAuthKeyRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

func (r *DescribeLivePushAuthKeyRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLivePushAuthKeyRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLivePushAuthKeyRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLivePushAuthKeyResponseParams struct {
	// Push authentication key information.
	PushAuthKeyInfo *PushAuthKeyInfo `json:"PushAuthKeyInfo,omitnil,omitempty" name:"PushAuthKeyInfo"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLivePushAuthKeyResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLivePushAuthKeyResponseParams `json:"Response"`
}

func (r *DescribeLivePushAuthKeyResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLivePushAuthKeyResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveRecordRulesRequestParams struct {

}

type DescribeLiveRecordRulesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveRecordRulesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveRecordRulesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveRecordRulesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveRecordRulesResponseParams struct {
	// List of rules.
	Rules []*RuleInfo `json:"Rules,omitnil,omitempty" name:"Rules"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveRecordRulesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveRecordRulesResponseParams `json:"Response"`
}

func (r *DescribeLiveRecordRulesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveRecordRulesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveRecordTemplateRequestParams struct {
	// Template ID obtained by [DescribeLiveRecordTemplates](https://intl.cloud.tencent.com/document/product/267/32609?from_cn_redirect=1).
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DescribeLiveRecordTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID obtained by [DescribeLiveRecordTemplates](https://intl.cloud.tencent.com/document/product/267/32609?from_cn_redirect=1).
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DescribeLiveRecordTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveRecordTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveRecordTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveRecordTemplateResponseParams struct {
	// Recording template information.
	Template *RecordTemplateInfo `json:"Template,omitnil,omitempty" name:"Template"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveRecordTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveRecordTemplateResponseParams `json:"Response"`
}

func (r *DescribeLiveRecordTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveRecordTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveRecordTemplatesRequestParams struct {
	// Whether it is an LCB template. Default value: 0.
	// 0: LVB.
	// 1: LCB.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`
}

type DescribeLiveRecordTemplatesRequest struct {
	*tchttp.BaseRequest
	
	// Whether it is an LCB template. Default value: 0.
	// 0: LVB.
	// 1: LCB.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`
}

func (r *DescribeLiveRecordTemplatesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveRecordTemplatesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "IsDelayLive")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveRecordTemplatesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveRecordTemplatesResponseParams struct {
	// Recording template information list.
	Templates []*RecordTemplateInfo `json:"Templates,omitnil,omitempty" name:"Templates"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveRecordTemplatesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveRecordTemplatesResponseParams `json:"Response"`
}

func (r *DescribeLiveRecordTemplatesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveRecordTemplatesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveSnapshotRulesRequestParams struct {

}

type DescribeLiveSnapshotRulesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveSnapshotRulesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveSnapshotRulesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveSnapshotRulesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveSnapshotRulesResponseParams struct {
	// Rule list.
	Rules []*RuleInfo `json:"Rules,omitnil,omitempty" name:"Rules"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveSnapshotRulesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveSnapshotRulesResponseParams `json:"Response"`
}

func (r *DescribeLiveSnapshotRulesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveSnapshotRulesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveSnapshotTemplateRequestParams struct {
	// Template ID.
	// Template ID returned by the [CreateLiveSnapshotTemplate](https://intl.cloud.tencent.com/document/product/267/32624?from_cn_redirect=1) API call.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DescribeLiveSnapshotTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	// Template ID returned by the [CreateLiveSnapshotTemplate](https://intl.cloud.tencent.com/document/product/267/32624?from_cn_redirect=1) API call.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DescribeLiveSnapshotTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveSnapshotTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveSnapshotTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveSnapshotTemplateResponseParams struct {
	// Screencapturing template information.
	Template *SnapshotTemplateInfo `json:"Template,omitnil,omitempty" name:"Template"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveSnapshotTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveSnapshotTemplateResponseParams `json:"Response"`
}

func (r *DescribeLiveSnapshotTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveSnapshotTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveSnapshotTemplatesRequestParams struct {

}

type DescribeLiveSnapshotTemplatesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveSnapshotTemplatesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveSnapshotTemplatesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveSnapshotTemplatesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveSnapshotTemplatesResponseParams struct {
	// Screencapturing template list.
	Templates []*SnapshotTemplateInfo `json:"Templates,omitnil,omitempty" name:"Templates"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveSnapshotTemplatesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveSnapshotTemplatesResponseParams `json:"Response"`
}

func (r *DescribeLiveSnapshotTemplatesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveSnapshotTemplatesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamEventListRequestParams struct {
	// Start time. 
	// In UTC format, such as 2018-12-29T19:00:00Z.
	// This supports querying the history of 60 days.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// End time.
	// In UTC format, such as 2018-12-29T20:00:00Z.
	// This cannot be after the current time and cannot be more than 30 days after the start time.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name; query with wildcard (*) is not supported; fuzzy match by default.
	// The IsStrict field can be used to change to exact query.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Page number to get.
	// Default value: 1.
	// Note: Currently, query for up to 10,000 entries is supported.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	// Maximum value: 100.
	// Value range: any integer between 1 and 100.
	// Default value: 10.
	// Note: currently, query for up to 10,000 entries is supported.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Whether to filter. No filtering by default.
	// 0: No filtering at all.
	// 1: Filter out the failing streams and return only the successful ones.
	IsFilter *int64 `json:"IsFilter,omitnil,omitempty" name:"IsFilter"`

	// Whether to query exactly. Fuzzy match by default.
	// 0: Fuzzy match.
	// 1: Exact query.
	// Note: This parameter takes effect when StreamName is used.
	IsStrict *int64 `json:"IsStrict,omitnil,omitempty" name:"IsStrict"`

	// Whether to display in ascending order by end time. Descending order by default.
	// 0: Descending.
	// 1: Ascending.
	IsAsc *int64 `json:"IsAsc,omitnil,omitempty" name:"IsAsc"`
}

type DescribeLiveStreamEventListRequest struct {
	*tchttp.BaseRequest
	
	// Start time. 
	// In UTC format, such as 2018-12-29T19:00:00Z.
	// This supports querying the history of 60 days.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// End time.
	// In UTC format, such as 2018-12-29T20:00:00Z.
	// This cannot be after the current time and cannot be more than 30 days after the start time.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name; query with wildcard (*) is not supported; fuzzy match by default.
	// The IsStrict field can be used to change to exact query.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Page number to get.
	// Default value: 1.
	// Note: Currently, query for up to 10,000 entries is supported.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	// Maximum value: 100.
	// Value range: any integer between 1 and 100.
	// Default value: 10.
	// Note: currently, query for up to 10,000 entries is supported.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Whether to filter. No filtering by default.
	// 0: No filtering at all.
	// 1: Filter out the failing streams and return only the successful ones.
	IsFilter *int64 `json:"IsFilter,omitnil,omitempty" name:"IsFilter"`

	// Whether to query exactly. Fuzzy match by default.
	// 0: Fuzzy match.
	// 1: Exact query.
	// Note: This parameter takes effect when StreamName is used.
	IsStrict *int64 `json:"IsStrict,omitnil,omitempty" name:"IsStrict"`

	// Whether to display in ascending order by end time. Descending order by default.
	// 0: Descending.
	// 1: Ascending.
	IsAsc *int64 `json:"IsAsc,omitnil,omitempty" name:"IsAsc"`
}

func (r *DescribeLiveStreamEventListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamEventListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "AppName")
	delete(f, "DomainName")
	delete(f, "StreamName")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "IsFilter")
	delete(f, "IsStrict")
	delete(f, "IsAsc")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveStreamEventListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamEventListResponseParams struct {
	// List of streaming events.
	EventList []*StreamEventInfo `json:"EventList,omitnil,omitempty" name:"EventList"`

	// Page number.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Total number of eligible ones.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveStreamEventListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveStreamEventListResponseParams `json:"Response"`
}

func (r *DescribeLiveStreamEventListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamEventListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamOnlineListRequestParams struct {
	// Push domain name. If you use multiple paths, enter the `DomainName`.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default. If you use multiple paths, enter the `AppName`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Page number to get. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Maximum value: 100. 
	// Value: any integer between 10 and 100.
	// Default value: 10.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Stream name, which is used for exact query.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DescribeLiveStreamOnlineListRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name. If you use multiple paths, enter the `DomainName`.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default. If you use multiple paths, enter the `AppName`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Page number to get. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Maximum value: 100. 
	// Value: any integer between 10 and 100.
	// Default value: 10.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Stream name, which is used for exact query.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DescribeLiveStreamOnlineListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamOnlineListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveStreamOnlineListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamOnlineListResponseParams struct {
	// Total number of eligible ones.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// Page number.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries displayed per page.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Active push information list.
	OnlineInfo []*StreamOnlineInfo `json:"OnlineInfo,omitnil,omitempty" name:"OnlineInfo"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveStreamOnlineListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveStreamOnlineListResponseParams `json:"Response"`
}

func (r *DescribeLiveStreamOnlineListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamOnlineListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamPublishedListRequestParams struct {
	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// End time.
	// In UTC format, such as 2016-06-30T19:00:00Z.
	// This cannot be after the current time.
	// Note: The difference between EndTime and StartTime cannot be greater than 30 days.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Start time. 
	// In UTC format, such as 2016-06-29T19:00:00Z.
	// This supports querying data in the past 60 days.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default. Fuzzy match is not supported.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Page number to get.
	// Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	// Maximum value: 100
	// Valid values: integers between 10 and 100
	// Default value: 10
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Stream name, which supports fuzzy match.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DescribeLiveStreamPublishedListRequest struct {
	*tchttp.BaseRequest
	
	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// End time.
	// In UTC format, such as 2016-06-30T19:00:00Z.
	// This cannot be after the current time.
	// Note: The difference between EndTime and StartTime cannot be greater than 30 days.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Start time. 
	// In UTC format, such as 2016-06-29T19:00:00Z.
	// This supports querying data in the past 60 days.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default. Fuzzy match is not supported.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Page number to get.
	// Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	// Maximum value: 100
	// Valid values: integers between 10 and 100
	// Default value: 10
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Stream name, which supports fuzzy match.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DescribeLiveStreamPublishedListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamPublishedListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "EndTime")
	delete(f, "StartTime")
	delete(f, "AppName")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveStreamPublishedListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamPublishedListResponseParams struct {
	// Push record information.
	PublishInfo []*StreamName `json:"PublishInfo,omitnil,omitempty" name:"PublishInfo"`

	// Page number.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Total number of eligible ones.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveStreamPublishedListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveStreamPublishedListResponseParams `json:"Response"`
}

func (r *DescribeLiveStreamPublishedListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamPublishedListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamPushInfoListRequestParams struct {
	// Push domain name.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Number of pages,
	// Value range: [1,10000],
	// Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page,
	// Value range: [1,1000],
	// Default value: 200.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`
}

type DescribeLiveStreamPushInfoListRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// Push path, which is the same as the `AppName` in push and playback addresses and is `live` by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Number of pages,
	// Value range: [1,10000],
	// Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page,
	// Value range: [1,1000],
	// Default value: 200.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`
}

func (r *DescribeLiveStreamPushInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamPushInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "PushDomain")
	delete(f, "AppName")
	delete(f, "PageNum")
	delete(f, "PageSize")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveStreamPushInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamPushInfoListResponseParams struct {
	// Live stream statistics list.
	DataInfoList []*PushDataInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// Total number of live streams.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// Page number where the current data resides.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of live streams per page.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveStreamPushInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveStreamPushInfoListResponseParams `json:"Response"`
}

func (r *DescribeLiveStreamPushInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamPushInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamStateRequestParams struct {
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type DescribeLiveStreamStateRequest struct {
	*tchttp.BaseRequest
	
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *DescribeLiveStreamStateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamStateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "AppName")
	delete(f, "DomainName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveStreamStateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveStreamStateResponseParams struct {
	// Stream status,
	// active: active
	// inactive: Inactive
	// forbid: forbidden.
	StreamState *string `json:"StreamState,omitnil,omitempty" name:"StreamState"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveStreamStateResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveStreamStateResponseParams `json:"Response"`
}

func (r *DescribeLiveStreamStateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveStreamStateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTimeShiftBillInfoListRequestParams struct {
	// The start time for query. You can query data from the past three months. The longest time period that can be queried is one month.
	// 
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time for query. You can query data from the past three months. The longest time period that can be queried is one month.
	// 
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The push domains to query. If you leave this empty, the time shifting billing data of all push domains will be returned.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`
}

type DescribeLiveTimeShiftBillInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time for query. You can query data from the past three months. The longest time period that can be queried is one month.
	// 
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time for query. You can query data from the past three months. The longest time period that can be queried is one month.
	// 
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The push domains to query. If you leave this empty, the time shifting billing data of all push domains will be returned.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`
}

func (r *DescribeLiveTimeShiftBillInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTimeShiftBillInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PushDomains")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTimeShiftBillInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTimeShiftBillInfoListResponseParams struct {
	// The time shifting billing data.
	DataInfoList []*TimeShiftBillData `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTimeShiftBillInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTimeShiftBillInfoListResponseParams `json:"Response"`
}

func (r *DescribeLiveTimeShiftBillInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTimeShiftBillInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTimeShiftRulesRequestParams struct {

}

type DescribeLiveTimeShiftRulesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveTimeShiftRulesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTimeShiftRulesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTimeShiftRulesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTimeShiftRulesResponseParams struct {
	// The information of the rules.
	Rules []*RuleInfo `json:"Rules,omitnil,omitempty" name:"Rules"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTimeShiftRulesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTimeShiftRulesResponseParams `json:"Response"`
}

func (r *DescribeLiveTimeShiftRulesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTimeShiftRulesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTimeShiftTemplatesRequestParams struct {

}

type DescribeLiveTimeShiftTemplatesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveTimeShiftTemplatesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTimeShiftTemplatesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTimeShiftTemplatesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTimeShiftTemplatesResponseParams struct {
	// The information of the templates.
	Templates []*TimeShiftTemplate `json:"Templates,omitnil,omitempty" name:"Templates"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTimeShiftTemplatesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTimeShiftTemplatesResponseParams `json:"Response"`
}

func (r *DescribeLiveTimeShiftTemplatesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTimeShiftTemplatesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeDetailInfoRequestParams struct {
	// Push domain name.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Query date (UTC+8)
	// Format: yyyymmdd
	// Note: you can query the statistics for a day in the past one month, with yesterday as the latest date allowed.
	DayTime *string `json:"DayTime,omitnil,omitempty" name:"DayTime"`

	// Number of pages. Default value: 1.
	// Up to 100 pages.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Default value: 20,
	// Value range: [10,1000].
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Start date (UTC+8)
	// Format: yyyymmdd
	// Note: details for the last one month can be queried.
	StartDayTime *string `json:"StartDayTime,omitnil,omitempty" name:"StartDayTime"`

	// End date (UTC+8)
	// Format: yyyymmdd
	// Note: you can query the statistics for a period in the past one month, with yesterday as the latest date allowed. You must specify either `DayTime`, or `StartDayTime` and `EndDayTime`. If you specify all three parameters, only `DayTime` will be applied.
	EndDayTime *string `json:"EndDayTime,omitnil,omitempty" name:"EndDayTime"`
}

type DescribeLiveTranscodeDetailInfoRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Query date (UTC+8)
	// Format: yyyymmdd
	// Note: you can query the statistics for a day in the past one month, with yesterday as the latest date allowed.
	DayTime *string `json:"DayTime,omitnil,omitempty" name:"DayTime"`

	// Number of pages. Default value: 1.
	// Up to 100 pages.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Default value: 20,
	// Value range: [10,1000].
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Start date (UTC+8)
	// Format: yyyymmdd
	// Note: details for the last one month can be queried.
	StartDayTime *string `json:"StartDayTime,omitnil,omitempty" name:"StartDayTime"`

	// End date (UTC+8)
	// Format: yyyymmdd
	// Note: you can query the statistics for a period in the past one month, with yesterday as the latest date allowed. You must specify either `DayTime`, or `StartDayTime` and `EndDayTime`. If you specify all three parameters, only `DayTime` will be applied.
	EndDayTime *string `json:"EndDayTime,omitnil,omitempty" name:"EndDayTime"`
}

func (r *DescribeLiveTranscodeDetailInfoRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeDetailInfoRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "PushDomain")
	delete(f, "StreamName")
	delete(f, "DayTime")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "StartDayTime")
	delete(f, "EndDayTime")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTranscodeDetailInfoRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeDetailInfoResponseParams struct {
	// Statistics list.
	DataInfoList []*TranscodeDetailInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// Page number.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Total number.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTranscodeDetailInfoResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTranscodeDetailInfoResponseParams `json:"Response"`
}

func (r *DescribeLiveTranscodeDetailInfoResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeDetailInfoResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeRulesRequestParams struct {
	// An array of template IDs to be filtered.
	TemplateIds []*int64 `json:"TemplateIds,omitnil,omitempty" name:"TemplateIds"`

	// An array of domain names to be filtered.
	DomainNames []*string `json:"DomainNames,omitnil,omitempty" name:"DomainNames"`
}

type DescribeLiveTranscodeRulesRequest struct {
	*tchttp.BaseRequest
	
	// An array of template IDs to be filtered.
	TemplateIds []*int64 `json:"TemplateIds,omitnil,omitempty" name:"TemplateIds"`

	// An array of domain names to be filtered.
	DomainNames []*string `json:"DomainNames,omitnil,omitempty" name:"DomainNames"`
}

func (r *DescribeLiveTranscodeRulesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeRulesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateIds")
	delete(f, "DomainNames")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTranscodeRulesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeRulesResponseParams struct {
	// List of transcoding rules.
	Rules []*RuleInfo `json:"Rules,omitnil,omitempty" name:"Rules"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTranscodeRulesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTranscodeRulesResponseParams `json:"Response"`
}

func (r *DescribeLiveTranscodeRulesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeRulesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeTemplateRequestParams struct {
	// Template ID.
	// Note: get the template ID in the returned value of the [CreateLiveTranscodeTemplate](https://intl.cloud.tencent.com/document/product/267/32646?from_cn_redirect=1) API call.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

type DescribeLiveTranscodeTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	// Note: get the template ID in the returned value of the [CreateLiveTranscodeTemplate](https://intl.cloud.tencent.com/document/product/267/32646?from_cn_redirect=1) API call.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`
}

func (r *DescribeLiveTranscodeTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTranscodeTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeTemplateResponseParams struct {
	// Template information.
	Template *TemplateInfo `json:"Template,omitnil,omitempty" name:"Template"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTranscodeTemplateResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTranscodeTemplateResponseParams `json:"Response"`
}

func (r *DescribeLiveTranscodeTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeTemplatesRequestParams struct {

}

type DescribeLiveTranscodeTemplatesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveTranscodeTemplatesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeTemplatesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTranscodeTemplatesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeTemplatesResponseParams struct {
	// List of transcoding templates.
	Templates []*TemplateInfo `json:"Templates,omitnil,omitempty" name:"Templates"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTranscodeTemplatesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTranscodeTemplatesResponseParams `json:"Response"`
}

func (r *DescribeLiveTranscodeTemplatesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeTemplatesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeTotalInfoRequestParams struct {
	// The start time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed three months. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed three months. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// List of push domains to query. If this parameter is left empty, the data of all domains is queried.
	// If this parameter is specified, the data returned will be on an hourly basis.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`

	// Valid values:
	// `Mainland`: queries transcoding data in the Chinese mainland
	// `Oversea`: queries transcoding data outside the Chinese mainland
	// By default, the data both in and outside the Chinese mainland is queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`
}

type DescribeLiveTranscodeTotalInfoRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed three months. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last three months, the gap between the start time and the end time cannot exceed three months. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// List of push domains to query. If this parameter is left empty, the data of all domains is queried.
	// If this parameter is specified, the data returned will be on an hourly basis.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`

	// Valid values:
	// `Mainland`: queries transcoding data in the Chinese mainland
	// `Oversea`: queries transcoding data outside the Chinese mainland
	// By default, the data both in and outside the Chinese mainland is queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`
}

func (r *DescribeLiveTranscodeTotalInfoRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeTotalInfoRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PushDomains")
	delete(f, "MainlandOrOversea")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveTranscodeTotalInfoRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveTranscodeTotalInfoResponseParams struct {
	// List of transcoding data
	// Note: This field may return `null`, indicating that no valid value can be found.
	DataInfoList []*TranscodeTotalInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveTranscodeTotalInfoResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveTranscodeTotalInfoResponseParams `json:"Response"`
}

func (r *DescribeLiveTranscodeTotalInfoResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveTranscodeTotalInfoResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveWatermarkRequestParams struct {
	// Watermark ID returned by the `DescribeLiveWatermarks` API.
	WatermarkId *uint64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`
}

type DescribeLiveWatermarkRequest struct {
	*tchttp.BaseRequest
	
	// Watermark ID returned by the `DescribeLiveWatermarks` API.
	WatermarkId *uint64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`
}

func (r *DescribeLiveWatermarkRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveWatermarkRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "WatermarkId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveWatermarkRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveWatermarkResponseParams struct {
	// Watermark information.
	Watermark *WatermarkInfo `json:"Watermark,omitnil,omitempty" name:"Watermark"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveWatermarkResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveWatermarkResponseParams `json:"Response"`
}

func (r *DescribeLiveWatermarkResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveWatermarkResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveWatermarkRulesRequestParams struct {

}

type DescribeLiveWatermarkRulesRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveWatermarkRulesRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveWatermarkRulesRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveWatermarkRulesRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveWatermarkRulesResponseParams struct {
	// Watermarking rule list.
	Rules []*RuleInfo `json:"Rules,omitnil,omitempty" name:"Rules"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveWatermarkRulesResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveWatermarkRulesResponseParams `json:"Response"`
}

func (r *DescribeLiveWatermarkRulesResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveWatermarkRulesResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveWatermarksRequestParams struct {

}

type DescribeLiveWatermarksRequest struct {
	*tchttp.BaseRequest
	
}

func (r *DescribeLiveWatermarksRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveWatermarksRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeLiveWatermarksRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeLiveWatermarksResponseParams struct {
	// Total number of watermarks.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Watermark information list.
	WatermarkList []*WatermarkInfo `json:"WatermarkList,omitnil,omitempty" name:"WatermarkList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeLiveWatermarksResponse struct {
	*tchttp.BaseResponse
	Response *DescribeLiveWatermarksResponseParams `json:"Response"`
}

func (r *DescribeLiveWatermarksResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeLiveWatermarksResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribePlayErrorCodeDetailInfoListRequestParams struct {
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Query granularity:
	// 1: 1-minute granularity.
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`

	// Yes. Valid values: "4xx", "5xx". Mixed codes in the format of `4xx,5xx` are also supported.
	StatType *string `json:"StatType,omitnil,omitempty" name:"StatType"`

	// Playback domain name list.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`
}

type DescribePlayErrorCodeDetailInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Query granularity:
	// 1: 1-minute granularity.
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`

	// Yes. Valid values: "4xx", "5xx". Mixed codes in the format of `4xx,5xx` are also supported.
	StatType *string `json:"StatType,omitnil,omitempty" name:"StatType"`

	// Playback domain name list.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`
}

func (r *DescribePlayErrorCodeDetailInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribePlayErrorCodeDetailInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "Granularity")
	delete(f, "StatType")
	delete(f, "PlayDomains")
	delete(f, "MainlandOrOversea")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribePlayErrorCodeDetailInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribePlayErrorCodeDetailInfoListResponseParams struct {
	// Statistics list.
	HttpCodeList []*HttpCodeInfo `json:"HttpCodeList,omitnil,omitempty" name:"HttpCodeList"`

	// Statistics type.
	StatType *string `json:"StatType,omitnil,omitempty" name:"StatType"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribePlayErrorCodeDetailInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribePlayErrorCodeDetailInfoListResponseParams `json:"Response"`
}

func (r *DescribePlayErrorCodeDetailInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribePlayErrorCodeDetailInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribePlayErrorCodeSumInfoListRequestParams struct {
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name list. If this parameter is left empty, full data will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Number of pages. Value range: [1,1000]. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000]. Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Grouping parameter. Valid values: CountryProIsp (default value), Country (country/region). Grouping is made by country/region + district + ISP by default. Currently, districts and ISPs outside Mainland China cannot be recognized.
	GroupType *string `json:"GroupType,omitnil,omitempty" name:"GroupType"`

	// Language used in the output field. Valid values: Chinese (default), English. Currently, country/region, district, and ISP parameters support multiple languages.
	OutLanguage *string `json:"OutLanguage,omitnil,omitempty" name:"OutLanguage"`
}

type DescribePlayErrorCodeSumInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name list. If this parameter is left empty, full data will be queried.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Number of pages. Value range: [1,1000]. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000]. Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Grouping parameter. Valid values: CountryProIsp (default value), Country (country/region). Grouping is made by country/region + district + ISP by default. Currently, districts and ISPs outside Mainland China cannot be recognized.
	GroupType *string `json:"GroupType,omitnil,omitempty" name:"GroupType"`

	// Language used in the output field. Valid values: Chinese (default), English. Currently, country/region, district, and ISP parameters support multiple languages.
	OutLanguage *string `json:"OutLanguage,omitnil,omitempty" name:"OutLanguage"`
}

func (r *DescribePlayErrorCodeSumInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribePlayErrorCodeSumInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PlayDomains")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "MainlandOrOversea")
	delete(f, "GroupType")
	delete(f, "OutLanguage")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribePlayErrorCodeSumInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribePlayErrorCodeSumInfoListResponseParams struct {
	// Information of error codes starting with 2, 3, 4, or 5 by district and ISP.
	ProIspInfoList []*ProIspPlayCodeDataInfo `json:"ProIspInfoList,omitnil,omitempty" name:"ProIspInfoList"`

	// Total occurrences of all status codes.
	TotalCodeAll *uint64 `json:"TotalCodeAll,omitnil,omitempty" name:"TotalCodeAll"`

	// Occurrences of 4xx status codes.
	TotalCode4xx *uint64 `json:"TotalCode4xx,omitnil,omitempty" name:"TotalCode4xx"`

	// Occurrences of 5xx status codes.
	TotalCode5xx *uint64 `json:"TotalCode5xx,omitnil,omitempty" name:"TotalCode5xx"`

	// Total occurrences of each status code.
	TotalCodeList []*PlayCodeTotalInfo `json:"TotalCodeList,omitnil,omitempty" name:"TotalCodeList"`

	// Page number.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// Total number of results.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Occurrences of 2xx status codes.
	TotalCode2xx *uint64 `json:"TotalCode2xx,omitnil,omitempty" name:"TotalCode2xx"`

	// Occurrences of 3xx status codes.
	TotalCode3xx *uint64 `json:"TotalCode3xx,omitnil,omitempty" name:"TotalCode3xx"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribePlayErrorCodeSumInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribePlayErrorCodeSumInfoListResponseParams `json:"Response"`
}

func (r *DescribePlayErrorCodeSumInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribePlayErrorCodeSumInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeProvinceIspPlayInfoListRequestParams struct {
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Supported granularities:
	// 1: 1-minute granularity (the query interval should be within 1 day)
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`

	// Statistical metric type:
	// "Bandwidth": bandwidth
	// "FluxPerSecond": average traffic
	// "Flux": traffic
	// "Request": number of requests
	// "Online": number of concurrent connections
	StatType *string `json:"StatType,omitnil,omitempty" name:"StatType"`

	// Playback domain name list.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// List of the districts to be queried, such as Beijing.
	ProvinceNames []*string `json:"ProvinceNames,omitnil,omitempty" name:"ProvinceNames"`

	// List of the ISPs to be queried, such as China Mobile. If this parameter is left empty, the data of all ISPs will be queried.
	IspNames []*string `json:"IspNames,omitnil,omitempty" name:"IspNames"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// IP type:
	// "Ipv6": IPv6 data
	// Data of all IPs will be returned if this parameter is left empty.
	IpType *string `json:"IpType,omitnil,omitempty" name:"IpType"`
}

type DescribeProvinceIspPlayInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Supported granularities:
	// 1: 1-minute granularity (the query interval should be within 1 day)
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`

	// Statistical metric type:
	// "Bandwidth": bandwidth
	// "FluxPerSecond": average traffic
	// "Flux": traffic
	// "Request": number of requests
	// "Online": number of concurrent connections
	StatType *string `json:"StatType,omitnil,omitempty" name:"StatType"`

	// Playback domain name list.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// List of the districts to be queried, such as Beijing.
	ProvinceNames []*string `json:"ProvinceNames,omitnil,omitempty" name:"ProvinceNames"`

	// List of the ISPs to be queried, such as China Mobile. If this parameter is left empty, the data of all ISPs will be queried.
	IspNames []*string `json:"IspNames,omitnil,omitempty" name:"IspNames"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// IP type:
	// "Ipv6": IPv6 data
	// Data of all IPs will be returned if this parameter is left empty.
	IpType *string `json:"IpType,omitnil,omitempty" name:"IpType"`
}

func (r *DescribeProvinceIspPlayInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeProvinceIspPlayInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "Granularity")
	delete(f, "StatType")
	delete(f, "PlayDomains")
	delete(f, "ProvinceNames")
	delete(f, "IspNames")
	delete(f, "MainlandOrOversea")
	delete(f, "IpType")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeProvinceIspPlayInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeProvinceIspPlayInfoListResponseParams struct {
	// Playback information list.
	DataInfoList []*PlayStatInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// Statistics type, which is the same as the input parameter.
	StatType *string `json:"StatType,omitnil,omitempty" name:"StatType"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeProvinceIspPlayInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeProvinceIspPlayInfoListResponseParams `json:"Response"`
}

func (r *DescribeProvinceIspPlayInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeProvinceIspPlayInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeRecordTaskRequestParams struct {
	// The start time of the tasks to retrieve in Unix timestamp. The time range should not be earlier than 90 days before the current time, and the query span should not exceed one week.
	StartTime *uint64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the tasks to retrieve in Unix timestamp. The EndTime must be greater than the StartTime. The time range should not be earlier than 90 days before the current time, and the query span should not exceed one week. (Note: the start and end times of the task must be within the query time range).
	EndTime *uint64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Page token used for batch retrieval: If a single request cannot retrieve all data, the interface will return a ScrollToken. The next request carrying this token will start retrieving from the next record.
	ScrollToken *string `json:"ScrollToken,omitnil,omitempty" name:"ScrollToken"`
}

type DescribeRecordTaskRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the tasks to retrieve in Unix timestamp. The time range should not be earlier than 90 days before the current time, and the query span should not exceed one week.
	StartTime *uint64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the tasks to retrieve in Unix timestamp. The EndTime must be greater than the StartTime. The time range should not be earlier than 90 days before the current time, and the query span should not exceed one week. (Note: the start and end times of the task must be within the query time range).
	EndTime *uint64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Page token used for batch retrieval: If a single request cannot retrieve all data, the interface will return a ScrollToken. The next request carrying this token will start retrieving from the next record.
	ScrollToken *string `json:"ScrollToken,omitnil,omitempty" name:"ScrollToken"`
}

func (r *DescribeRecordTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeRecordTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "StreamName")
	delete(f, "DomainName")
	delete(f, "AppName")
	delete(f, "ScrollToken")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeRecordTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeRecordTaskResponseParams struct {
	// Page token: When the request does not return all data, this field indicates the token of the next record. When this field is empty, it means there is no more data.
	ScrollToken *string `json:"ScrollToken,omitnil,omitempty" name:"ScrollToken"`

	// List of recording tasks. When this field is empty, it means all data has been returned.
	TaskList []*RecordTask `json:"TaskList,omitnil,omitempty" name:"TaskList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeRecordTaskResponse struct {
	*tchttp.BaseResponse
	Response *DescribeRecordTaskResponseParams `json:"Response"`
}

func (r *DescribeRecordTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeRecordTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeScreenShotSheetNumListRequestParams struct {
	// Start time in UTC time in the format of `yyyy-mm-ddTHH:MM:SSZ`.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// End time in UTC time in the format of `yyyy-mm-ddTHH:MM:SSZ`. Data for the last year can be queried.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Region information. Valid values: Mainland, Oversea. The former is to query data within Mainland China, while the latter outside Mainland China. If this parameter is left empty, data of all regions will be queried.
	Zone *string `json:"Zone,omitnil,omitempty" name:"Zone"`

	// Push domain name (data at the domain name level after November 1, 2019 can be queried).
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`

	// Data granularity. There is a 1.5-hour delay in data reporting. Valid values: `Minute` (5-minute granularity; query period of up to 31 days); `Day` (1-day granularity based on UTC+8:00; query period of up to 186 days)
	Granularity *string `json:"Granularity,omitnil,omitempty" name:"Granularity"`
}

type DescribeScreenShotSheetNumListRequest struct {
	*tchttp.BaseRequest
	
	// Start time in UTC time in the format of `yyyy-mm-ddTHH:MM:SSZ`.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// End time in UTC time in the format of `yyyy-mm-ddTHH:MM:SSZ`. Data for the last year can be queried.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Region information. Valid values: Mainland, Oversea. The former is to query data within Mainland China, while the latter outside Mainland China. If this parameter is left empty, data of all regions will be queried.
	Zone *string `json:"Zone,omitnil,omitempty" name:"Zone"`

	// Push domain name (data at the domain name level after November 1, 2019 can be queried).
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`

	// Data granularity. There is a 1.5-hour delay in data reporting. Valid values: `Minute` (5-minute granularity; query period of up to 31 days); `Day` (1-day granularity based on UTC+8:00; query period of up to 186 days)
	Granularity *string `json:"Granularity,omitnil,omitempty" name:"Granularity"`
}

func (r *DescribeScreenShotSheetNumListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeScreenShotSheetNumListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "Zone")
	delete(f, "PushDomains")
	delete(f, "Granularity")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeScreenShotSheetNumListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeScreenShotSheetNumListResponseParams struct {
	// Data information list.
	DataInfoList []*TimeValue `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeScreenShotSheetNumListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeScreenShotSheetNumListResponseParams `json:"Response"`
}

func (r *DescribeScreenShotSheetNumListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeScreenShotSheetNumListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeStreamDayPlayInfoListRequestParams struct {
	// Date in the format of YYYY-mm-dd
	// Data is available at 3am Beijing Time the next day. You are recommended to query the latest data after this time point. Data in the last 3 months can be queried.
	DayTime *string `json:"DayTime,omitnil,omitempty" name:"DayTime"`

	// Playback domain name.
	PlayDomain *string `json:"PlayDomain,omitnil,omitempty" name:"PlayDomain"`

	// Page number. Value range: [1,1000]. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [100,1000]. Default value: 1,000.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Valid values:
	// Mainland: query data for Mainland China,
	// Oversea: query data for regions outside Mainland China,
	// Default: query data for all regions.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Service name. Valid values: LVB, LEB. If this parameter is left empty, all data of LVB and LEB will be queried.
	ServiceName *string `json:"ServiceName,omitnil,omitempty" name:"ServiceName"`
}

type DescribeStreamDayPlayInfoListRequest struct {
	*tchttp.BaseRequest
	
	// Date in the format of YYYY-mm-dd
	// Data is available at 3am Beijing Time the next day. You are recommended to query the latest data after this time point. Data in the last 3 months can be queried.
	DayTime *string `json:"DayTime,omitnil,omitempty" name:"DayTime"`

	// Playback domain name.
	PlayDomain *string `json:"PlayDomain,omitnil,omitempty" name:"PlayDomain"`

	// Page number. Value range: [1,1000]. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [100,1000]. Default value: 1,000.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Valid values:
	// Mainland: query data for Mainland China,
	// Oversea: query data for regions outside Mainland China,
	// Default: query data for all regions.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Service name. Valid values: LVB, LEB. If this parameter is left empty, all data of LVB and LEB will be queried.
	ServiceName *string `json:"ServiceName,omitnil,omitempty" name:"ServiceName"`
}

func (r *DescribeStreamDayPlayInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeStreamDayPlayInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DayTime")
	delete(f, "PlayDomain")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "MainlandOrOversea")
	delete(f, "ServiceName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeStreamDayPlayInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeStreamDayPlayInfoListResponseParams struct {
	// Playback data information list.
	DataInfoList []*PlayDataInfoByStream `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// Total number.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// Page number where the current data resides.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeStreamDayPlayInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeStreamDayPlayInfoListResponseParams `json:"Response"`
}

func (r *DescribeStreamDayPlayInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeStreamDayPlayInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeStreamPlayInfoListRequestParams struct {
	// The start time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed twenty-four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed twenty-four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name,
	// If this parameter is left empty, data of live streams of all playback domain names will be queried.
	PlayDomain *string `json:"PlayDomain,omitnil,omitempty" name:"PlayDomain"`

	// Stream name (exact match).
	// If this parameter is left empty, full playback data will be queried.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push address. Its value is the same as the `AppName` in playback address. It supports exact match, and takes effect only when `StreamName` is passed at the same time.
	// If it is left empty, the full playback data will be queried.
	// Note: to query by `AppName`, you need to submit a ticket first. After your application succeeds, it will take about 5 business days (subject to the time in the reply) for the configuration to take effect.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Service name. Valid values: LVB, LEB. If this parameter is left empty, all data of LVB and LEB will be queried.
	ServiceName *string `json:"ServiceName,omitnil,omitempty" name:"ServiceName"`
}

type DescribeStreamPlayInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed twenty-four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed twenty-four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name,
	// If this parameter is left empty, data of live streams of all playback domain names will be queried.
	PlayDomain *string `json:"PlayDomain,omitnil,omitempty" name:"PlayDomain"`

	// Stream name (exact match).
	// If this parameter is left empty, full playback data will be queried.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push address. Its value is the same as the `AppName` in playback address. It supports exact match, and takes effect only when `StreamName` is passed at the same time.
	// If it is left empty, the full playback data will be queried.
	// Note: to query by `AppName`, you need to submit a ticket first. After your application succeeds, it will take about 5 business days (subject to the time in the reply) for the configuration to take effect.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Service name. Valid values: LVB, LEB. If this parameter is left empty, all data of LVB and LEB will be queried.
	ServiceName *string `json:"ServiceName,omitnil,omitempty" name:"ServiceName"`
}

func (r *DescribeStreamPlayInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeStreamPlayInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PlayDomain")
	delete(f, "StreamName")
	delete(f, "AppName")
	delete(f, "ServiceName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeStreamPlayInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeStreamPlayInfoListResponseParams struct {
	// Statistics list at a 1-minute granularity.
	DataInfoList []*DayStreamPlayInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeStreamPlayInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeStreamPlayInfoListResponseParams `json:"Response"`
}

func (r *DescribeStreamPlayInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeStreamPlayInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeStreamPushInfoListRequestParams struct {
	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The start time of the request, supports data query for the last seven days, the gap between the start time and the end time cannot exceed three hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last seven days, the gap between the start time and the end time cannot exceed three hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The push domain.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// The push path, which should be the same as `AppName` in the push and playback URL. The default value is `live`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`
}

type DescribeStreamPushInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The start time of the request, supports data query for the last seven days, the gap between the start time and the end time cannot exceed three hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last seven days, the gap between the start time and the end time cannot exceed three hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The push domain.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// The push path, which should be the same as `AppName` in the push and playback URL. The default value is `live`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`
}

func (r *DescribeStreamPushInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeStreamPushInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StreamName")
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PushDomain")
	delete(f, "AppName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeStreamPushInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeStreamPushInfoListResponseParams struct {
	// Returned data list.
	DataInfoList []*PushQualityData `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeStreamPushInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeStreamPushInfoListResponseParams `json:"Response"`
}

func (r *DescribeStreamPushInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeStreamPushInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTimeShiftRecordDetailRequestParams struct {
	// The push domain.
	Domain *string `json:"Domain,omitnil,omitempty" name:"Domain"`

	// The push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The start time, which must be a Unix timestamp.
	StartTime *int64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time, which must be a Unix timestamp. 
	EndTime *int64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The group the push domain belongs to. You don’t need to specify this parameter if the domain doesn’t belong to any group or the group name is an empty string.
	DomainGroup *string `json:"DomainGroup,omitnil,omitempty" name:"DomainGroup"`

	// The transcoding template ID. You don’t need to specify this parameter if the transcoding template ID is `0`.
	TransCodeId *uint64 `json:"TransCodeId,omitnil,omitempty" name:"TransCodeId"`
}

type DescribeTimeShiftRecordDetailRequest struct {
	*tchttp.BaseRequest
	
	// The push domain.
	Domain *string `json:"Domain,omitnil,omitempty" name:"Domain"`

	// The push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The start time, which must be a Unix timestamp.
	StartTime *int64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time, which must be a Unix timestamp. 
	EndTime *int64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The group the push domain belongs to. You don’t need to specify this parameter if the domain doesn’t belong to any group or the group name is an empty string.
	DomainGroup *string `json:"DomainGroup,omitnil,omitempty" name:"DomainGroup"`

	// The transcoding template ID. You don’t need to specify this parameter if the transcoding template ID is `0`.
	TransCodeId *uint64 `json:"TransCodeId,omitnil,omitempty" name:"TransCodeId"`
}

func (r *DescribeTimeShiftRecordDetailRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTimeShiftRecordDetailRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "Domain")
	delete(f, "AppName")
	delete(f, "StreamName")
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "DomainGroup")
	delete(f, "TransCodeId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeTimeShiftRecordDetailRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTimeShiftRecordDetailResponseParams struct {
	// The number of sessions recorded.
	// Note: This field may return null, indicating that no valid values can be obtained.
	RecordList []*TimeShiftRecord `json:"RecordList,omitnil,omitempty" name:"RecordList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeTimeShiftRecordDetailResponse struct {
	*tchttp.BaseResponse
	Response *DescribeTimeShiftRecordDetailResponseParams `json:"Response"`
}

func (r *DescribeTimeShiftRecordDetailResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTimeShiftRecordDetailResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTimeShiftStreamListRequestParams struct {
	// The start time, which must be a Unix timestamp.
	StartTime *int64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time, which must be a Unix timestamp.
	EndTime *int64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The push domain.
	Domain *string `json:"Domain,omitnil,omitempty" name:"Domain"`

	// The group the push domain belongs to.
	DomainGroup *string `json:"DomainGroup,omitnil,omitempty" name:"DomainGroup"`

	// The maximum number of records to return. Value range: 0-100. If you do not specify this parameter or pass in `0`, 
	// the default value `100` will be used. If you pass in a negative number or a value greater than 100, an error will be returned.
	PageSize *int64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// The number of page to pull records from. If you do not specify this parameter, the default value `1` will be used.
	PageNum *int64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`
}

type DescribeTimeShiftStreamListRequest struct {
	*tchttp.BaseRequest
	
	// The start time, which must be a Unix timestamp.
	StartTime *int64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time, which must be a Unix timestamp.
	EndTime *int64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The push domain.
	Domain *string `json:"Domain,omitnil,omitempty" name:"Domain"`

	// The group the push domain belongs to.
	DomainGroup *string `json:"DomainGroup,omitnil,omitempty" name:"DomainGroup"`

	// The maximum number of records to return. Value range: 0-100. If you do not specify this parameter or pass in `0`, 
	// the default value `100` will be used. If you pass in a negative number or a value greater than 100, an error will be returned.
	PageSize *int64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// The number of page to pull records from. If you do not specify this parameter, the default value `1` will be used.
	PageNum *int64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`
}

func (r *DescribeTimeShiftStreamListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTimeShiftStreamListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "StreamName")
	delete(f, "Domain")
	delete(f, "DomainGroup")
	delete(f, "PageSize")
	delete(f, "PageNum")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeTimeShiftStreamListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTimeShiftStreamListResponseParams struct {
	// The total number of records in the specified time period.
	TotalSize *int64 `json:"TotalSize,omitnil,omitempty" name:"TotalSize"`

	// The information of the streams.
	// Note: This field may return null, indicating that no valid values can be obtained.
	StreamList []*TimeShiftStreamInfo `json:"StreamList,omitnil,omitempty" name:"StreamList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeTimeShiftStreamListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeTimeShiftStreamListResponseParams `json:"Response"`
}

func (r *DescribeTimeShiftStreamListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTimeShiftStreamListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTopClientIpSumInfoListRequestParams struct {
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name. If this parameter is left empty, full data will be queried by default.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Page number. Value range: [1,1000]. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000]. Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Sorting metric. Valid values: TotalRequest (default value), FailedRequest, TotalFlux.
	OrderParam *string `json:"OrderParam,omitnil,omitempty" name:"OrderParam"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Language used in the output field. Valid values: Chinese (default), English. Currently, country/region, district, and ISP parameters support multiple languages.
	OutLanguage *string `json:"OutLanguage,omitnil,omitempty" name:"OutLanguage"`
}

type DescribeTopClientIpSumInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Playback domain name. If this parameter is left empty, full data will be queried by default.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Page number. Value range: [1,1000]. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000]. Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Sorting metric. Valid values: TotalRequest (default value), FailedRequest, TotalFlux.
	OrderParam *string `json:"OrderParam,omitnil,omitempty" name:"OrderParam"`

	// Region. Valid values: Mainland (data for Mainland China), Oversea (data for regions outside Mainland China), China (data for China, including Hong Kong, Macao, and Taiwan), Foreign (data for regions outside China, excluding Hong Kong, Macao, and Taiwan), Global (default). If this parameter is left empty, data for all regions will be queried.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`

	// Language used in the output field. Valid values: Chinese (default), English. Currently, country/region, district, and ISP parameters support multiple languages.
	OutLanguage *string `json:"OutLanguage,omitnil,omitempty" name:"OutLanguage"`
}

func (r *DescribeTopClientIpSumInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTopClientIpSumInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PlayDomains")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "OrderParam")
	delete(f, "MainlandOrOversea")
	delete(f, "OutLanguage")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeTopClientIpSumInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTopClientIpSumInfoListResponseParams struct {
	// Page number. Value range: [1,1000]. Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000]. Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Sorting metric. Valid values: "TotalRequest", "FailedRequest", "TotalFlux".
	OrderParam *string `json:"OrderParam,omitnil,omitempty" name:"OrderParam"`

	// Total number of results.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of result pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// Data content.
	DataInfoList []*ClientIpPlaySumInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeTopClientIpSumInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeTopClientIpSumInfoListResponseParams `json:"Response"`
}

func (r *DescribeTopClientIpSumInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTopClientIpSumInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTranscodeTaskNumRequestParams struct {
	// The start time of the request, supports data query for the last forty days, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last forty days, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The push domains to query. If you do not pass a value, all push domains will be queried.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`
}

type DescribeTranscodeTaskNumRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last forty days, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last forty days, the gap between the start time and the end time cannot exceed one day. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The push domains to query. If you do not pass a value, all push domains will be queried.
	PushDomains []*string `json:"PushDomains,omitnil,omitempty" name:"PushDomains"`
}

func (r *DescribeTranscodeTaskNumRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTranscodeTaskNumRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "PushDomains")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeTranscodeTaskNumRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeTranscodeTaskNumResponseParams struct {
	// The number of tasks.
	DataInfoList []*TranscodeTaskNum `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeTranscodeTaskNumResponse struct {
	*tchttp.BaseResponse
	Response *DescribeTranscodeTaskNumResponseParams `json:"Response"`
}

func (r *DescribeTranscodeTaskNumResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeTranscodeTaskNumResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeUploadStreamNumsRequestParams struct {
	// The start time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// LVB domain names. If this parameter is left empty, data of all domain names will be queried.
	Domains []*string `json:"Domains,omitnil,omitempty" name:"Domains"`

	// Time granularity of the data. Valid values:
	// 5: 5-minute granularity (the query period is up to 1 day)
	// 1440: 1-day granularity (the query period is up to 1 month)
	// Default value: 5
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`
}

type DescribeUploadStreamNumsRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one month, the gap between the start time and the end time cannot exceed one month. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// LVB domain names. If this parameter is left empty, data of all domain names will be queried.
	Domains []*string `json:"Domains,omitnil,omitempty" name:"Domains"`

	// Time granularity of the data. Valid values:
	// 5: 5-minute granularity (the query period is up to 1 day)
	// 1440: 1-day granularity (the query period is up to 1 month)
	// Default value: 5
	Granularity *uint64 `json:"Granularity,omitnil,omitempty" name:"Granularity"`
}

func (r *DescribeUploadStreamNumsRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeUploadStreamNumsRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "Domains")
	delete(f, "Granularity")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeUploadStreamNumsRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeUploadStreamNumsResponseParams struct {
	// Detailed data.
	DataInfoList []*ConcurrentRecordStreamNum `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeUploadStreamNumsResponse struct {
	*tchttp.BaseResponse
	Response *DescribeUploadStreamNumsResponseParams `json:"Response"`
}

func (r *DescribeUploadStreamNumsResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeUploadStreamNumsResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeVisitTopSumInfoListRequestParams struct {
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Bandwidth metric. Valid values: "Domain", "StreamId".
	TopIndex *string `json:"TopIndex,omitnil,omitempty" name:"TopIndex"`

	// Playback domain name. If this parameter is left empty, full data will be queried by default.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Page number,
	// Value range: [1,1000],
	// Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000].
	// Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Sorting metric. Valid values: "AvgFluxPerSecond", "TotalRequest" (default), "TotalFlux".
	OrderParam *string `json:"OrderParam,omitnil,omitempty" name:"OrderParam"`
}

type DescribeVisitTopSumInfoListRequest struct {
	*tchttp.BaseRequest
	
	// The start time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format, for details, see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the request, supports data query for the last one day, the gap between the start time and the end time cannot exceed four hours. Interface request supports two time formats:
	// 1) YYYY-MM-DDThh:mm:ssZ: ISO time format,for details,see [ISO Date Format Description](https://cloud.tencent.com/document/product/267/38543#:~:text=I- ,ISO,-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F)
	// 2) YYYY-MM-DD hh:mm:ss: When using this format, it represents Beijing time by default.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Bandwidth metric. Valid values: "Domain", "StreamId".
	TopIndex *string `json:"TopIndex,omitnil,omitempty" name:"TopIndex"`

	// Playback domain name. If this parameter is left empty, full data will be queried by default.
	PlayDomains []*string `json:"PlayDomains,omitnil,omitempty" name:"PlayDomains"`

	// Page number,
	// Value range: [1,1000],
	// Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000].
	// Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Sorting metric. Valid values: "AvgFluxPerSecond", "TotalRequest" (default), "TotalFlux".
	OrderParam *string `json:"OrderParam,omitnil,omitempty" name:"OrderParam"`
}

func (r *DescribeVisitTopSumInfoListRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeVisitTopSumInfoListRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "TopIndex")
	delete(f, "PlayDomains")
	delete(f, "PageNum")
	delete(f, "PageSize")
	delete(f, "OrderParam")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DescribeVisitTopSumInfoListRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DescribeVisitTopSumInfoListResponseParams struct {
	// Page number,
	// Value range: [1,1000],
	// Default value: 1.
	PageNum *uint64 `json:"PageNum,omitnil,omitempty" name:"PageNum"`

	// Number of entries per page. Value range: [1,1000].
	// Default value: 20.
	PageSize *uint64 `json:"PageSize,omitnil,omitempty" name:"PageSize"`

	// Bandwidth metric. Valid values: "Domain", "StreamId".
	TopIndex *string `json:"TopIndex,omitnil,omitempty" name:"TopIndex"`

	// Sorting metric. Valid values: AvgFluxPerSecond (sort by average traffic per second), TotalRequest (sort by total requests), TotalFlux (sort by total traffic). Default value: TotalRequest.
	OrderParam *string `json:"OrderParam,omitnil,omitempty" name:"OrderParam"`

	// Total number of results.
	TotalNum *uint64 `json:"TotalNum,omitnil,omitempty" name:"TotalNum"`

	// Total number of result pages.
	TotalPage *uint64 `json:"TotalPage,omitnil,omitempty" name:"TotalPage"`

	// Data content.
	DataInfoList []*PlaySumStatInfo `json:"DataInfoList,omitnil,omitempty" name:"DataInfoList"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DescribeVisitTopSumInfoListResponse struct {
	*tchttp.BaseResponse
	Response *DescribeVisitTopSumInfoListResponseParams `json:"Response"`
}

func (r *DescribeVisitTopSumInfoListResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DescribeVisitTopSumInfoListResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type DomainCertInfo struct {
	// Certificate ID.
	CertId *int64 `json:"CertId,omitnil,omitempty" name:"CertId"`

	// Certificate name.
	CertName *string `json:"CertName,omitnil,omitempty" name:"CertName"`

	// Description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// The creation time in UTC format.
	// Note: Beijing time (UTC+8) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// Certificate content.
	HttpsCrt *string `json:"HttpsCrt,omitnil,omitempty" name:"HttpsCrt"`

	// Certificate type.
	// 0: user-added certificate
	// 1: Tencent Cloud-hosted certificate.
	CertType *int64 `json:"CertType,omitnil,omitempty" name:"CertType"`

	// The certificate expiration time in UTC format.
	// Note: Beijing time (UTC+8) is used.
	CertExpireTime *string `json:"CertExpireTime,omitnil,omitempty" name:"CertExpireTime"`

	// Domain name that uses this certificate.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Certificate status.
	Status *int64 `json:"Status,omitnil,omitempty" name:"Status"`

	// List of domain names in the certificate.
	// ["*.x.com"] for example.
	// Note: this field may return `null`, indicating that no valid values can be obtained.
	CertDomains []*string `json:"CertDomains,omitnil,omitempty" name:"CertDomains"`

	// Tencent Cloud SSL certificate ID.
	// Note: this field may return `null`, indicating that no valid values can be obtained.
	CloudCertId *string `json:"CloudCertId,omitnil,omitempty" name:"CloudCertId"`
}

type DomainInfo struct {
	// LVB domain name.
	Name *string `json:"Name,omitnil,omitempty" name:"Name"`

	// Domain name type:
	// 0: push.
	// 1: playback.
	Type *uint64 `json:"Type,omitnil,omitempty" name:"Type"`

	// Domain name status:
	// 0: deactivated.
	// 1: activated.
	Status *uint64 `json:"Status,omitnil,omitempty" name:"Status"`

	// The time when the domain was added.
	// Note: Beijing time (UTC+8) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// Whether there is a CNAME record pointing to a fixed rule domain name:
	// 0: no.
	// 1: yes.
	BCName *uint64 `json:"BCName,omitnil,omitempty" name:"BCName"`

	// Domain name corresponding to CNAME record.
	TargetDomain *string `json:"TargetDomain,omitnil,omitempty" name:"TargetDomain"`

	// Playback region. This parameter is valid only if `Type` is 1.
	// 1: in Mainland China.
	// 2: global.
	// 3: outside Mainland China.
	PlayType *int64 `json:"PlayType,omitnil,omitempty" name:"PlayType"`

	// Whether it is LCB:
	// 0: LVB.
	// 1: LCB.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// Information of currently used CNAME record.
	CurrentCName *string `json:"CurrentCName,omitnil,omitempty" name:"CurrentCName"`

	// Disused parameter, which can be ignored.
	RentTag *int64 `json:"RentTag,omitnil,omitempty" name:"RentTag"`

	// A disused parameter.
	// Note: Beijing time (UTC+8) is used.
	RentExpireTime *string `json:"RentExpireTime,omitnil,omitempty" name:"RentExpireTime"`

	// 0: LVB.
	// 1: LVB on Mini Program.
	// Note: this field may return null, indicating that no valid values can be obtained.
	IsMiniProgramLive *int64 `json:"IsMiniProgramLive,omitnil,omitempty" name:"IsMiniProgramLive"`
}

// Predefined struct for user
type DropLiveStreamRequestParams struct {
	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Your push domain.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which should be the same as `AppName` in the push and playback URL. The default value is `live`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`
}

type DropLiveStreamRequest struct {
	*tchttp.BaseRequest
	
	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Your push domain.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The push path, which should be the same as `AppName` in the push and playback URL. The default value is `live`.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`
}

func (r *DropLiveStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DropLiveStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StreamName")
	delete(f, "DomainName")
	delete(f, "AppName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "DropLiveStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type DropLiveStreamResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type DropLiveStreamResponse struct {
	*tchttp.BaseResponse
	Response *DropLiveStreamResponseParams `json:"Response"`
}

func (r *DropLiveStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *DropLiveStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type EnableLiveDomainRequestParams struct {
	// LVB domain name to be enabled.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type EnableLiveDomainRequest struct {
	*tchttp.BaseRequest
	
	// LVB domain name to be enabled.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

func (r *EnableLiveDomainRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *EnableLiveDomainRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "EnableLiveDomainRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type EnableLiveDomainResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type EnableLiveDomainResponse struct {
	*tchttp.BaseResponse
	Response *EnableLiveDomainResponseParams `json:"Response"`
}

func (r *EnableLiveDomainResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *EnableLiveDomainResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type FlvSpecialParam struct {
	// Whether to enable upload while recording. This parameter is only valid for FLV recording.
	UploadInRecording *bool `json:"UploadInRecording,omitnil,omitempty" name:"UploadInRecording"`
}

// Predefined struct for user
type ForbidLiveDomainRequestParams struct {
	// LVB domain name to be disabled.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type ForbidLiveDomainRequest struct {
	*tchttp.BaseRequest
	
	// LVB domain name to be disabled.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

func (r *ForbidLiveDomainRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ForbidLiveDomainRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ForbidLiveDomainRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ForbidLiveDomainResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ForbidLiveDomainResponse struct {
	*tchttp.BaseResponse
	Response *ForbidLiveDomainResponseParams `json:"Response"`
}

func (r *ForbidLiveDomainResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ForbidLiveDomainResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ForbidLiveStreamRequestParams struct {
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The time (in UTC format) to resume the stream, such as 2018-11-29T19:00:00Z.
	// Notes:
	// 1. The default stream disabling period is seven days. A stream can be disabled for up to 90 days.
	// 2. Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	ResumeTime *string `json:"ResumeTime,omitnil,omitempty" name:"ResumeTime"`

	// Reason for forbidding.
	// Note: Be sure to enter the reason for forbidding to avoid any faulty operations.
	// Length limit: 2,048 bytes.
	Reason *string `json:"Reason,omitnil,omitempty" name:"Reason"`
}

type ForbidLiveStreamRequest struct {
	*tchttp.BaseRequest
	
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The time (in UTC format) to resume the stream, such as 2018-11-29T19:00:00Z.
	// Notes:
	// 1. The default stream disabling period is seven days. A stream can be disabled for up to 90 days.
	// 2. Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	ResumeTime *string `json:"ResumeTime,omitnil,omitempty" name:"ResumeTime"`

	// Reason for forbidding.
	// Note: Be sure to enter the reason for forbidding to avoid any faulty operations.
	// Length limit: 2,048 bytes.
	Reason *string `json:"Reason,omitnil,omitempty" name:"Reason"`
}

func (r *ForbidLiveStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ForbidLiveStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "AppName")
	delete(f, "DomainName")
	delete(f, "StreamName")
	delete(f, "ResumeTime")
	delete(f, "Reason")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ForbidLiveStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ForbidLiveStreamResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ForbidLiveStreamResponse struct {
	*tchttp.BaseResponse
	Response *ForbidLiveStreamResponseParams `json:"Response"`
}

func (r *ForbidLiveStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ForbidLiveStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type ForbidStreamInfo struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The creation time.
	// Note: Beijing time (UTC+8) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// The end time.
	// Note: Beijing time (UTC+8) is used.
	ExpireTime *string `json:"ExpireTime,omitnil,omitempty" name:"ExpireTime"`

	// The push path.
	// Note: This field may return null, indicating that no valid values can be obtained.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The push domain name.
	// Note: This field may return null, indicating that no valid values can be obtained.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type GroupProIspDataInfo struct {
	// District.
	ProvinceName *string `json:"ProvinceName,omitnil,omitempty" name:"ProvinceName"`

	// ISP.
	IspName *string `json:"IspName,omitnil,omitempty" name:"IspName"`

	// Detailed data at the minute level.
	DetailInfoList []*CdnPlayStatData `json:"DetailInfoList,omitnil,omitempty" name:"DetailInfoList"`
}

type HlsSpecialParam struct {
	// Timeout period for restarting an interrupted HLS push.
	// Value range: [0, 1,800].
	FlowContinueDuration *uint64 `json:"FlowContinueDuration,omitnil,omitempty" name:"FlowContinueDuration"`
}

type HttpCodeInfo struct {
	// HTTP return code.
	// Example: "2xx", "3xx", "4xx", "5xx".
	HttpCode *string `json:"HttpCode,omitnil,omitempty" name:"HttpCode"`

	// Statistics. 0 will be added for points in time when there is no data.
	ValueList []*HttpCodeValue `json:"ValueList,omitnil,omitempty" name:"ValueList"`
}

type HttpCodeValue struct {
	// Time in the format of `yyyy-mm-dd HH:MM:SS`.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Occurrences.
	Numbers *uint64 `json:"Numbers,omitnil,omitempty" name:"Numbers"`

	// Proportion.
	Percentage *float64 `json:"Percentage,omitnil,omitempty" name:"Percentage"`
}

type HttpStatusData struct {
	// Data point in time,
	// In the format of `yyyy-mm-dd HH:MM:SS`.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Playback status code details.
	HttpStatusInfoList []*HttpStatusInfo `json:"HttpStatusInfoList,omitnil,omitempty" name:"HttpStatusInfoList"`
}

type HttpStatusInfo struct {
	// Playback HTTP status code.
	HttpStatus *string `json:"HttpStatus,omitnil,omitempty" name:"HttpStatus"`

	// Quantity.
	Num *uint64 `json:"Num,omitnil,omitempty" name:"Num"`
}

type LiveCertDomainInfo struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable HTTPS for the domain.
	// 1: Enable
	// 0: Disable
	// -1: Keep the current configuration
	Status *int64 `json:"Status,omitnil,omitempty" name:"Status"`
}

type LiveDomainCertBindings struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The remarks for the certificate. This parameter is the same as `CertName`.
	CertificateAlias *string `json:"CertificateAlias,omitnil,omitempty" name:"CertificateAlias"`

	// The certificate type.
	// 0: Self-owned certificate
	// 1: Tencent Cloud-hosted certificate
	CertType *int64 `json:"CertType,omitnil,omitempty" name:"CertType"`

	// Whether HTTPS is enabled.
	// 1: Enabled
	// 0: Disabled
	Status *int64 `json:"Status,omitnil,omitempty" name:"Status"`

	// The certificate expiration time.
	// Note: Beijing time (UTC+8) is used.
	CertExpireTime *string `json:"CertExpireTime,omitnil,omitempty" name:"CertExpireTime"`

	// The certificate ID.
	CertId *int64 `json:"CertId,omitnil,omitempty" name:"CertId"`

	// The SSL certificate ID assigned by Tencent Cloud.
	CloudCertId *string `json:"CloudCertId,omitnil,omitempty" name:"CloudCertId"`

	// The last updated time.
	// Note: Beijing time (UTC+8) is used.
	// Note: This field may return null, indicating that no valid values can be obtained.
	UpdateTime *string `json:"UpdateTime,omitnil,omitempty" name:"UpdateTime"`
}

// Predefined struct for user
type ModifyLiveCallbackTemplateRequestParams struct {
	// Template ID returned by the `DescribeLiveCallbackTemplates` API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Stream starting callback URL.
	StreamBeginNotifyUrl *string `json:"StreamBeginNotifyUrl,omitnil,omitempty" name:"StreamBeginNotifyUrl"`

	// Interruption callback URL.
	StreamEndNotifyUrl *string `json:"StreamEndNotifyUrl,omitnil,omitempty" name:"StreamEndNotifyUrl"`

	// Recording callback URL.
	RecordNotifyUrl *string `json:"RecordNotifyUrl,omitnil,omitempty" name:"RecordNotifyUrl"`

	// Screencapturing callback URL.
	SnapshotNotifyUrl *string `json:"SnapshotNotifyUrl,omitnil,omitempty" name:"SnapshotNotifyUrl"`

	// Porn detection callback URL.
	PornCensorshipNotifyUrl *string `json:"PornCensorshipNotifyUrl,omitnil,omitempty" name:"PornCensorshipNotifyUrl"`

	// Callback key. The callback URL is public. For the callback signature, please see the event message notification document.
	// [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	CallbackKey *string `json:"CallbackKey,omitnil,omitempty" name:"CallbackKey"`

	// The push error callback URL.
	PushExceptionNotifyUrl *string `json:"PushExceptionNotifyUrl,omitnil,omitempty" name:"PushExceptionNotifyUrl"`
}

type ModifyLiveCallbackTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID returned by the `DescribeLiveCallbackTemplates` API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Stream starting callback URL.
	StreamBeginNotifyUrl *string `json:"StreamBeginNotifyUrl,omitnil,omitempty" name:"StreamBeginNotifyUrl"`

	// Interruption callback URL.
	StreamEndNotifyUrl *string `json:"StreamEndNotifyUrl,omitnil,omitempty" name:"StreamEndNotifyUrl"`

	// Recording callback URL.
	RecordNotifyUrl *string `json:"RecordNotifyUrl,omitnil,omitempty" name:"RecordNotifyUrl"`

	// Screencapturing callback URL.
	SnapshotNotifyUrl *string `json:"SnapshotNotifyUrl,omitnil,omitempty" name:"SnapshotNotifyUrl"`

	// Porn detection callback URL.
	PornCensorshipNotifyUrl *string `json:"PornCensorshipNotifyUrl,omitnil,omitempty" name:"PornCensorshipNotifyUrl"`

	// Callback key. The callback URL is public. For the callback signature, please see the event message notification document.
	// [Event Message Notification](https://intl.cloud.tencent.com/document/product/267/32744?from_cn_redirect=1).
	CallbackKey *string `json:"CallbackKey,omitnil,omitempty" name:"CallbackKey"`

	// The push error callback URL.
	PushExceptionNotifyUrl *string `json:"PushExceptionNotifyUrl,omitnil,omitempty" name:"PushExceptionNotifyUrl"`
}

func (r *ModifyLiveCallbackTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveCallbackTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	delete(f, "TemplateName")
	delete(f, "Description")
	delete(f, "StreamBeginNotifyUrl")
	delete(f, "StreamEndNotifyUrl")
	delete(f, "RecordNotifyUrl")
	delete(f, "SnapshotNotifyUrl")
	delete(f, "PornCensorshipNotifyUrl")
	delete(f, "CallbackKey")
	delete(f, "PushExceptionNotifyUrl")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLiveCallbackTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveCallbackTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLiveCallbackTemplateResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLiveCallbackTemplateResponseParams `json:"Response"`
}

func (r *ModifyLiveCallbackTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveCallbackTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveDomainCertBindingsRequestParams struct {
	// The playback domains to bind and whether to enable HTTPS for them.
	// If neither `CloudCertId` nor the public/private key is specified, and a domain is already bound with a certificate, this API will only update the HTTPS configuration of the domain and, if the certificate is a self-owned certificate, upload it to Tencent Cloud.
	DomainInfos []*LiveCertDomainInfo `json:"DomainInfos,omitnil,omitempty" name:"DomainInfos"`

	// The SSL certificate ID assigned by Tencent Cloud.
	// For details, see https://intl.cloud.tencent.com/document/api/400/41665?from_cn_redirect=1
	CloudCertId *string `json:"CloudCertId,omitnil,omitempty" name:"CloudCertId"`

	// The public key of the certificate.
	// You can specify either `CloudCertId` or the public/private key. If both are specified, the private and public key parameters will be ignored. If you pass in only the public and private keys, the corresponding certificate will be uploaded to Tencent Cloud SSL Certificate Service, which will generate a `CloudCertId` for the certificate.
	CertificatePublicKey *string `json:"CertificatePublicKey,omitnil,omitempty" name:"CertificatePublicKey"`

	// The private key of the certificate.
	// You can specify either `CloudCertId` or the public/private key. If both are specified, the private and public key parameters will be ignored. If you pass in only the public and private keys, the corresponding certificate will be uploaded to Tencent Cloud SSL Certificate Service, which will generate a `CloudCertId` for the certificate.
	CertificatePrivateKey *string `json:"CertificatePrivateKey,omitnil,omitempty" name:"CertificatePrivateKey"`

	// The remarks for the certificate in Tencent Cloud SSL Certificate Service. This parameter will be ignored if `CloudCertId` is specified.
	CertificateAlias *string `json:"CertificateAlias,omitnil,omitempty" name:"CertificateAlias"`
}

type ModifyLiveDomainCertBindingsRequest struct {
	*tchttp.BaseRequest
	
	// The playback domains to bind and whether to enable HTTPS for them.
	// If neither `CloudCertId` nor the public/private key is specified, and a domain is already bound with a certificate, this API will only update the HTTPS configuration of the domain and, if the certificate is a self-owned certificate, upload it to Tencent Cloud.
	DomainInfos []*LiveCertDomainInfo `json:"DomainInfos,omitnil,omitempty" name:"DomainInfos"`

	// The SSL certificate ID assigned by Tencent Cloud.
	// For details, see https://intl.cloud.tencent.com/document/api/400/41665?from_cn_redirect=1
	CloudCertId *string `json:"CloudCertId,omitnil,omitempty" name:"CloudCertId"`

	// The public key of the certificate.
	// You can specify either `CloudCertId` or the public/private key. If both are specified, the private and public key parameters will be ignored. If you pass in only the public and private keys, the corresponding certificate will be uploaded to Tencent Cloud SSL Certificate Service, which will generate a `CloudCertId` for the certificate.
	CertificatePublicKey *string `json:"CertificatePublicKey,omitnil,omitempty" name:"CertificatePublicKey"`

	// The private key of the certificate.
	// You can specify either `CloudCertId` or the public/private key. If both are specified, the private and public key parameters will be ignored. If you pass in only the public and private keys, the corresponding certificate will be uploaded to Tencent Cloud SSL Certificate Service, which will generate a `CloudCertId` for the certificate.
	CertificatePrivateKey *string `json:"CertificatePrivateKey,omitnil,omitempty" name:"CertificatePrivateKey"`

	// The remarks for the certificate in Tencent Cloud SSL Certificate Service. This parameter will be ignored if `CloudCertId` is specified.
	CertificateAlias *string `json:"CertificateAlias,omitnil,omitempty" name:"CertificateAlias"`
}

func (r *ModifyLiveDomainCertBindingsRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveDomainCertBindingsRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainInfos")
	delete(f, "CloudCertId")
	delete(f, "CertificatePublicKey")
	delete(f, "CertificatePrivateKey")
	delete(f, "CertificateAlias")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLiveDomainCertBindingsRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveDomainCertBindingsResponseParams struct {
	// The domains skipped due to certificate mismatch.
	MismatchedDomainNames []*string `json:"MismatchedDomainNames,omitnil,omitempty" name:"MismatchedDomainNames"`

	// The domains that the API failed to bind, including those in `MismatchedDomainNames`, and the error information.
	// Note: This field may return null, indicating that no valid values can be obtained.
	Errors []*BatchDomainOperateErrors `json:"Errors,omitnil,omitempty" name:"Errors"`

	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLiveDomainCertBindingsResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLiveDomainCertBindingsResponseParams `json:"Response"`
}

func (r *ModifyLiveDomainCertBindingsResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveDomainCertBindingsResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveDomainRefererRequestParams struct {
	// Playback domain name
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable referer allowlist/blocklist authentication for the current domain name
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// List type. Valid values: `0` (blocklist), `1` (allowlist)
	Type *int64 `json:"Type,omitnil,omitempty" name:"Type"`

	// Whether to allow empty referer. Valid values: `0` (no), `1` (yes)
	AllowEmpty *int64 `json:"AllowEmpty,omitnil,omitempty" name:"AllowEmpty"`

	// Referer list. Separate items in it with semicolons (;).
	Rules *string `json:"Rules,omitnil,omitempty" name:"Rules"`
}

type ModifyLiveDomainRefererRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable referer allowlist/blocklist authentication for the current domain name
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// List type. Valid values: `0` (blocklist), `1` (allowlist)
	Type *int64 `json:"Type,omitnil,omitempty" name:"Type"`

	// Whether to allow empty referer. Valid values: `0` (no), `1` (yes)
	AllowEmpty *int64 `json:"AllowEmpty,omitnil,omitempty" name:"AllowEmpty"`

	// Referer list. Separate items in it with semicolons (;).
	Rules *string `json:"Rules,omitnil,omitempty" name:"Rules"`
}

func (r *ModifyLiveDomainRefererRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveDomainRefererRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "Enable")
	delete(f, "Type")
	delete(f, "AllowEmpty")
	delete(f, "Rules")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLiveDomainRefererRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveDomainRefererResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLiveDomainRefererResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLiveDomainRefererResponseParams `json:"Response"`
}

func (r *ModifyLiveDomainRefererResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveDomainRefererResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePlayAuthKeyRequestParams struct {
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable. 0: disabled; 1: enabled.
	// If this parameter is left empty, the current value will not be modified.
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// Authentication key.
	// If this parameter is left empty, the current value will not be modified.
	AuthKey *string `json:"AuthKey,omitnil,omitempty" name:"AuthKey"`

	// Validity period in seconds.
	// If this parameter is left empty, the current value will not be modified.
	AuthDelta *uint64 `json:"AuthDelta,omitnil,omitempty" name:"AuthDelta"`

	// Backup authentication key.
	// If this parameter is left empty, the current value will not be modified.
	AuthBackKey *string `json:"AuthBackKey,omitnil,omitempty" name:"AuthBackKey"`
}

type ModifyLivePlayAuthKeyRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable. 0: disabled; 1: enabled.
	// If this parameter is left empty, the current value will not be modified.
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// Authentication key.
	// If this parameter is left empty, the current value will not be modified.
	AuthKey *string `json:"AuthKey,omitnil,omitempty" name:"AuthKey"`

	// Validity period in seconds.
	// If this parameter is left empty, the current value will not be modified.
	AuthDelta *uint64 `json:"AuthDelta,omitnil,omitempty" name:"AuthDelta"`

	// Backup authentication key.
	// If this parameter is left empty, the current value will not be modified.
	AuthBackKey *string `json:"AuthBackKey,omitnil,omitempty" name:"AuthBackKey"`
}

func (r *ModifyLivePlayAuthKeyRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePlayAuthKeyRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "Enable")
	delete(f, "AuthKey")
	delete(f, "AuthDelta")
	delete(f, "AuthBackKey")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLivePlayAuthKeyRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePlayAuthKeyResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLivePlayAuthKeyResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLivePlayAuthKeyResponseParams `json:"Response"`
}

func (r *ModifyLivePlayAuthKeyResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePlayAuthKeyResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePlayDomainRequestParams struct {
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Pull domain name type. 1: Mainland China. 2: global, 3: outside Mainland China
	PlayType *int64 `json:"PlayType,omitnil,omitempty" name:"PlayType"`
}

type ModifyLivePlayDomainRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Pull domain name type. 1: Mainland China. 2: global, 3: outside Mainland China
	PlayType *int64 `json:"PlayType,omitnil,omitempty" name:"PlayType"`
}

func (r *ModifyLivePlayDomainRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePlayDomainRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "PlayType")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLivePlayDomainRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePlayDomainResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLivePlayDomainResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLivePlayDomainResponseParams `json:"Response"`
}

func (r *ModifyLivePlayDomainResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePlayDomainResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePullStreamTaskRequestParams struct {
	// The task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`

	// The source URL(s).
	// If `SourceType` is `PullLivePushLive`, you can specify only one source URL.
	// If `SourceType` is `PullVodPushLive`, you can specify at most 30 source URLs.
	SourceUrls []*string `json:"SourceUrls,omitnil,omitempty" name:"SourceUrls"`

	// The start time.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time. Notes:
	// 1. The end time must be later than the start time.
	// 2. The end time and start time must be later than the current time.
	// 3. The end time and start time must be less than seven days apart.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The number of times to loop video files.
	// -1: Loop indefinitely
	// 0: Do not loop
	// > 0: The number of loop times. A task will end either when the videos are looped for the specified number of times or at the specified task end time, whichever is earlier.
	// This parameter is valid only if the source is video files.
	VodLoopTimes *int64 `json:"VodLoopTimes,omitnil,omitempty" name:"VodLoopTimes"`

	// The behavior after the source video files (`SourceUrls`) are changed.
	// ImmediateNewSource: Play the new videos immediately
	// ContinueBreakPoint: Finish the current video first and then pull from the new source.
	// This parameter is valid only if the source is video files.
	VodRefreshType *string `json:"VodRefreshType,omitnil,omitempty" name:"VodRefreshType"`

	// Whether to enable or pause the task. Valid values:
	// enable
	// pause
	Status *string `json:"Status,omitnil,omitempty" name:"Status"`

	// The events to listen for. If you do not pass this parameter, all events will be listened for.
	// TaskStart: Callback for starting a task
	// TaskExit: Callback for ending a task
	// VodSourceFileStart: Callback for starting to pull from video files
	// VodSourceFileFinish: Callback for stopping pulling from video files
	// ResetTaskConfig: Callback for modifying a task
	CallbackEvents []*string `json:"CallbackEvents,omitnil,omitempty" name:"CallbackEvents"`

	// A custom callback URL.
	// Callbacks will be sent to this URL.
	CallbackUrl *string `json:"CallbackUrl,omitnil,omitempty" name:"CallbackUrl"`

	// The index of the video to start from.
	// The value of this parameter cannot be smaller than 1 or larger than the number of elements in `SourceUrls`.
	FileIndex *int64 `json:"FileIndex,omitnil,omitempty" name:"FileIndex"`

	// The playback offset (seconds).
	// Notes:
	// 1. This parameter should be used together with `FileIndex`.
	OffsetTime *int64 `json:"OffsetTime,omitnil,omitempty" name:"OffsetTime"`

	// The remarks for the task.
	Comment *string `json:"Comment,omitnil,omitempty" name:"Comment"`

	// The backup source type.
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// Notes:
	// 1. Backup sources are supported only if the primary source type is live streaming.
	// 2. Leaving this parameter empty will reset the backup source.
	// 3. When pull from the primary source is interrupted, the system will pull from the backup source.
	// 4. If the backup source is a video file, each time the video is finished, the system will check if the primary source is recovered and will switch back if it is.
	BackupSourceType *string `json:"BackupSourceType,omitnil,omitempty" name:"BackupSourceType"`

	// The URL of the backup source.
	// You can specify only one backup source URL.
	BackupSourceUrl *string `json:"BackupSourceUrl,omitnil,omitempty" name:"BackupSourceUrl"`

	// The information of watermarks to add.
	// Notes:
	// 1. You can add up to four watermarks to different locations of the video.
	// 2. Make sure you use publicly accessible URLs for the watermark images.
	// 3. Supported image formats include PNG and JPG.
	// 4. If you change the watermark configuration of a task whose source is a list of video files, the new configuration will take effect for the next file in the list.
	// 5. If you change the watermark configuration of a task whose source is a live stream, the new configuration will take effect immediately.
	// 6. If you want to stop using watermarks, pass in an empty array.
	// 7. Currently, animated watermarks are not supported.
	WatermarkList []*PullPushWatermarkInfo `json:"WatermarkList,omitnil,omitempty" name:"WatermarkList"`

	// Whether to use local mode when the source type is video files. The default is `0`.
	// 0: Do not use local mode
	// 1: Use local mode
	// Note: If you enable local mode, MP4 files will be downloaded to local storage, and the local files will be used for push. This ensures more reliable push. Pushing a local file will incur additional fees.
	VodLocalMode *int64 `json:"VodLocalMode,omitnil,omitempty" name:"VodLocalMode"`
}

type ModifyLivePullStreamTaskRequest struct {
	*tchttp.BaseRequest
	
	// The task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`

	// The source URL(s).
	// If `SourceType` is `PullLivePushLive`, you can specify only one source URL.
	// If `SourceType` is `PullVodPushLive`, you can specify at most 30 source URLs.
	SourceUrls []*string `json:"SourceUrls,omitnil,omitempty" name:"SourceUrls"`

	// The start time.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time. Notes:
	// 1. The end time must be later than the start time.
	// 2. The end time and start time must be later than the current time.
	// 3. The end time and start time must be less than seven days apart.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The number of times to loop video files.
	// -1: Loop indefinitely
	// 0: Do not loop
	// > 0: The number of loop times. A task will end either when the videos are looped for the specified number of times or at the specified task end time, whichever is earlier.
	// This parameter is valid only if the source is video files.
	VodLoopTimes *int64 `json:"VodLoopTimes,omitnil,omitempty" name:"VodLoopTimes"`

	// The behavior after the source video files (`SourceUrls`) are changed.
	// ImmediateNewSource: Play the new videos immediately
	// ContinueBreakPoint: Finish the current video first and then pull from the new source.
	// This parameter is valid only if the source is video files.
	VodRefreshType *string `json:"VodRefreshType,omitnil,omitempty" name:"VodRefreshType"`

	// Whether to enable or pause the task. Valid values:
	// enable
	// pause
	Status *string `json:"Status,omitnil,omitempty" name:"Status"`

	// The events to listen for. If you do not pass this parameter, all events will be listened for.
	// TaskStart: Callback for starting a task
	// TaskExit: Callback for ending a task
	// VodSourceFileStart: Callback for starting to pull from video files
	// VodSourceFileFinish: Callback for stopping pulling from video files
	// ResetTaskConfig: Callback for modifying a task
	CallbackEvents []*string `json:"CallbackEvents,omitnil,omitempty" name:"CallbackEvents"`

	// A custom callback URL.
	// Callbacks will be sent to this URL.
	CallbackUrl *string `json:"CallbackUrl,omitnil,omitempty" name:"CallbackUrl"`

	// The index of the video to start from.
	// The value of this parameter cannot be smaller than 1 or larger than the number of elements in `SourceUrls`.
	FileIndex *int64 `json:"FileIndex,omitnil,omitempty" name:"FileIndex"`

	// The playback offset (seconds).
	// Notes:
	// 1. This parameter should be used together with `FileIndex`.
	OffsetTime *int64 `json:"OffsetTime,omitnil,omitempty" name:"OffsetTime"`

	// The remarks for the task.
	Comment *string `json:"Comment,omitnil,omitempty" name:"Comment"`

	// The backup source type.
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// Notes:
	// 1. Backup sources are supported only if the primary source type is live streaming.
	// 2. Leaving this parameter empty will reset the backup source.
	// 3. When pull from the primary source is interrupted, the system will pull from the backup source.
	// 4. If the backup source is a video file, each time the video is finished, the system will check if the primary source is recovered and will switch back if it is.
	BackupSourceType *string `json:"BackupSourceType,omitnil,omitempty" name:"BackupSourceType"`

	// The URL of the backup source.
	// You can specify only one backup source URL.
	BackupSourceUrl *string `json:"BackupSourceUrl,omitnil,omitempty" name:"BackupSourceUrl"`

	// The information of watermarks to add.
	// Notes:
	// 1. You can add up to four watermarks to different locations of the video.
	// 2. Make sure you use publicly accessible URLs for the watermark images.
	// 3. Supported image formats include PNG and JPG.
	// 4. If you change the watermark configuration of a task whose source is a list of video files, the new configuration will take effect for the next file in the list.
	// 5. If you change the watermark configuration of a task whose source is a live stream, the new configuration will take effect immediately.
	// 6. If you want to stop using watermarks, pass in an empty array.
	// 7. Currently, animated watermarks are not supported.
	WatermarkList []*PullPushWatermarkInfo `json:"WatermarkList,omitnil,omitempty" name:"WatermarkList"`

	// Whether to use local mode when the source type is video files. The default is `0`.
	// 0: Do not use local mode
	// 1: Use local mode
	// Note: If you enable local mode, MP4 files will be downloaded to local storage, and the local files will be used for push. This ensures more reliable push. Pushing a local file will incur additional fees.
	VodLocalMode *int64 `json:"VodLocalMode,omitnil,omitempty" name:"VodLocalMode"`
}

func (r *ModifyLivePullStreamTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePullStreamTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TaskId")
	delete(f, "Operator")
	delete(f, "SourceUrls")
	delete(f, "StartTime")
	delete(f, "EndTime")
	delete(f, "VodLoopTimes")
	delete(f, "VodRefreshType")
	delete(f, "Status")
	delete(f, "CallbackEvents")
	delete(f, "CallbackUrl")
	delete(f, "FileIndex")
	delete(f, "OffsetTime")
	delete(f, "Comment")
	delete(f, "BackupSourceType")
	delete(f, "BackupSourceUrl")
	delete(f, "WatermarkList")
	delete(f, "VodLocalMode")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLivePullStreamTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePullStreamTaskResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLivePullStreamTaskResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLivePullStreamTaskResponseParams `json:"Response"`
}

func (r *ModifyLivePullStreamTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePullStreamTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePushAuthKeyRequestParams struct {
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable. 0: disabled; 1: enabled.
	// If this parameter is left empty, the current value will not be modified.
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// Master authentication key.
	// If this parameter is left empty, the current value will not be modified.
	MasterAuthKey *string `json:"MasterAuthKey,omitnil,omitempty" name:"MasterAuthKey"`

	// Backup authentication key.
	// If this parameter is left empty, the current value will not be modified.
	BackupAuthKey *string `json:"BackupAuthKey,omitnil,omitempty" name:"BackupAuthKey"`

	// Validity period in seconds.
	AuthDelta *uint64 `json:"AuthDelta,omitnil,omitempty" name:"AuthDelta"`
}

type ModifyLivePushAuthKeyRequest struct {
	*tchttp.BaseRequest
	
	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable. 0: disabled; 1: enabled.
	// If this parameter is left empty, the current value will not be modified.
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// Master authentication key.
	// If this parameter is left empty, the current value will not be modified.
	MasterAuthKey *string `json:"MasterAuthKey,omitnil,omitempty" name:"MasterAuthKey"`

	// Backup authentication key.
	// If this parameter is left empty, the current value will not be modified.
	BackupAuthKey *string `json:"BackupAuthKey,omitnil,omitempty" name:"BackupAuthKey"`

	// Validity period in seconds.
	AuthDelta *uint64 `json:"AuthDelta,omitnil,omitempty" name:"AuthDelta"`
}

func (r *ModifyLivePushAuthKeyRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePushAuthKeyRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "Enable")
	delete(f, "MasterAuthKey")
	delete(f, "BackupAuthKey")
	delete(f, "AuthDelta")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLivePushAuthKeyRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLivePushAuthKeyResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLivePushAuthKeyResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLivePushAuthKeyResponseParams `json:"Response"`
}

func (r *ModifyLivePushAuthKeyResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLivePushAuthKeyResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveRecordTemplateRequestParams struct {
	// Template ID obtained through the `DescribeRecordTemplates` API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Message description
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// FLV recording parameter, which is set when FLV recording is enabled.
	FlvParam *RecordParam `json:"FlvParam,omitnil,omitempty" name:"FlvParam"`

	// HLS recording parameter, which is set when HLS recording is enabled.
	HlsParam *RecordParam `json:"HlsParam,omitnil,omitempty" name:"HlsParam"`

	// MP4 recording parameter, which is set when MP4 recording is enabled.
	Mp4Param *RecordParam `json:"Mp4Param,omitnil,omitempty" name:"Mp4Param"`

	// AAC recording parameter, which is set when AAC recording is enabled.
	AacParam *RecordParam `json:"AacParam,omitnil,omitempty" name:"AacParam"`

	// Custom HLS recording parameter.
	HlsSpecialParam *HlsSpecialParam `json:"HlsSpecialParam,omitnil,omitempty" name:"HlsSpecialParam"`

	// MP3 recording parameter, which is set when MP3 recording is enabled.
	Mp3Param *RecordParam `json:"Mp3Param,omitnil,omitempty" name:"Mp3Param"`

	// Whether to remove the watermark. This parameter is invalid if `IsDelayLive` is `1`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// A special parameter for FLV recording.
	FlvSpecialParam *FlvSpecialParam `json:"FlvSpecialParam,omitnil,omitempty" name:"FlvSpecialParam"`
}

type ModifyLiveRecordTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID obtained through the `DescribeRecordTemplates` API.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Message description
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// FLV recording parameter, which is set when FLV recording is enabled.
	FlvParam *RecordParam `json:"FlvParam,omitnil,omitempty" name:"FlvParam"`

	// HLS recording parameter, which is set when HLS recording is enabled.
	HlsParam *RecordParam `json:"HlsParam,omitnil,omitempty" name:"HlsParam"`

	// MP4 recording parameter, which is set when MP4 recording is enabled.
	Mp4Param *RecordParam `json:"Mp4Param,omitnil,omitempty" name:"Mp4Param"`

	// AAC recording parameter, which is set when AAC recording is enabled.
	AacParam *RecordParam `json:"AacParam,omitnil,omitempty" name:"AacParam"`

	// Custom HLS recording parameter.
	HlsSpecialParam *HlsSpecialParam `json:"HlsSpecialParam,omitnil,omitempty" name:"HlsSpecialParam"`

	// MP3 recording parameter, which is set when MP3 recording is enabled.
	Mp3Param *RecordParam `json:"Mp3Param,omitnil,omitempty" name:"Mp3Param"`

	// Whether to remove the watermark. This parameter is invalid if `IsDelayLive` is `1`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// A special parameter for FLV recording.
	FlvSpecialParam *FlvSpecialParam `json:"FlvSpecialParam,omitnil,omitempty" name:"FlvSpecialParam"`
}

func (r *ModifyLiveRecordTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveRecordTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	delete(f, "TemplateName")
	delete(f, "Description")
	delete(f, "FlvParam")
	delete(f, "HlsParam")
	delete(f, "Mp4Param")
	delete(f, "AacParam")
	delete(f, "HlsSpecialParam")
	delete(f, "Mp3Param")
	delete(f, "RemoveWatermark")
	delete(f, "FlvSpecialParam")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLiveRecordTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveRecordTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLiveRecordTemplateResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLiveRecordTemplateResponseParams `json:"Response"`
}

func (r *ModifyLiveRecordTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveRecordTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveSnapshotTemplateRequestParams struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The COS application ID.
	// **Please note that this parameter is required now**.
	CosAppId *int64 `json:"CosAppId,omitnil,omitempty" name:"CosAppId"`

	// The COS bucket name.
	// Note: Do not include the `-[appid]` part in the value of `CosBucket`.
	// **Please note that this parameter is required now**.
	CosBucket *string `json:"CosBucket,omitnil,omitempty" name:"CosBucket"`

	// The COS region.
	// **Please note that this parameter is required now**.
	CosRegion *string `json:"CosRegion,omitnil,omitempty" name:"CosRegion"`

	// Template name.
	// Maximum length: 255 bytes.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Description.
	// Maximum length: 1,024 bytes.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Screencapturing interval in seconds. Default value: 10s.
	// Value range: 5-300s.
	SnapshotInterval *int64 `json:"SnapshotInterval,omitnil,omitempty" name:"SnapshotInterval"`

	// Screenshot width. Default value: 0 (original width).
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Screenshot height. Default value: 0 (original height).
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Whether to enable porn detection. Default value: 0.
	// 0: do not enable.
	// 1: enable.
	PornFlag *int64 `json:"PornFlag,omitnil,omitempty" name:"PornFlag"`

	// COS bucket folder prefix.
	CosPrefix *string `json:"CosPrefix,omitnil,omitempty" name:"CosPrefix"`

	// COS filename.
	CosFileName *string `json:"CosFileName,omitnil,omitempty" name:"CosFileName"`
}

type ModifyLiveSnapshotTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The COS application ID.
	// **Please note that this parameter is required now**.
	CosAppId *int64 `json:"CosAppId,omitnil,omitempty" name:"CosAppId"`

	// The COS bucket name.
	// Note: Do not include the `-[appid]` part in the value of `CosBucket`.
	// **Please note that this parameter is required now**.
	CosBucket *string `json:"CosBucket,omitnil,omitempty" name:"CosBucket"`

	// The COS region.
	// **Please note that this parameter is required now**.
	CosRegion *string `json:"CosRegion,omitnil,omitempty" name:"CosRegion"`

	// Template name.
	// Maximum length: 255 bytes.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Description.
	// Maximum length: 1,024 bytes.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Screencapturing interval in seconds. Default value: 10s.
	// Value range: 5-300s.
	SnapshotInterval *int64 `json:"SnapshotInterval,omitnil,omitempty" name:"SnapshotInterval"`

	// Screenshot width. Default value: 0 (original width).
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Screenshot height. Default value: 0 (original height).
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Whether to enable porn detection. Default value: 0.
	// 0: do not enable.
	// 1: enable.
	PornFlag *int64 `json:"PornFlag,omitnil,omitempty" name:"PornFlag"`

	// COS bucket folder prefix.
	CosPrefix *string `json:"CosPrefix,omitnil,omitempty" name:"CosPrefix"`

	// COS filename.
	CosFileName *string `json:"CosFileName,omitnil,omitempty" name:"CosFileName"`
}

func (r *ModifyLiveSnapshotTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveSnapshotTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	delete(f, "CosAppId")
	delete(f, "CosBucket")
	delete(f, "CosRegion")
	delete(f, "TemplateName")
	delete(f, "Description")
	delete(f, "SnapshotInterval")
	delete(f, "Width")
	delete(f, "Height")
	delete(f, "PornFlag")
	delete(f, "CosPrefix")
	delete(f, "CosFileName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLiveSnapshotTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveSnapshotTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLiveSnapshotTemplateResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLiveSnapshotTemplateResponseParams `json:"Response"`
}

func (r *ModifyLiveSnapshotTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveSnapshotTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveTimeShiftTemplateRequestParams struct {
	// The time shifting template ID.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The template name.
	// Only letters, numbers, underscores, and hyphens are supported.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// The template description.
	// Maximum length: 1,024 bytes.
	// Only letters, numbers, underscores, and hyphens are supported.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// The time shifting duration.
	// Unit: Second.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// The segment size.
	// Value range: 3-10.
	// Unit: Second.
	// Default value: 5
	ItemDuration *uint64 `json:"ItemDuration,omitnil,omitempty" name:"ItemDuration"`

	// Whether to remove watermarks.
	// If you pass in `true`, the original stream will be recorded.
	// Default value: `false`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// The transcoding template IDs.
	// This API works only if `RemoveWatermark` is `false`.
	TranscodeTemplateIds []*int64 `json:"TranscodeTemplateIds,omitnil,omitempty" name:"TranscodeTemplateIds"`

	// The region.
	// `Mainland`: The Chinese mainland.
	// `Overseas`: Outside the Chinese mainland.
	// Default value: `Mainland`.
	Area *string `json:"Area,omitnil,omitempty" name:"Area"`
}

type ModifyLiveTimeShiftTemplateRequest struct {
	*tchttp.BaseRequest
	
	// The time shifting template ID.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The template name.
	// Only letters, numbers, underscores, and hyphens are supported.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// The template description.
	// Maximum length: 1,024 bytes.
	// Only letters, numbers, underscores, and hyphens are supported.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// The time shifting duration.
	// Unit: Second.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// The segment size.
	// Value range: 3-10.
	// Unit: Second.
	// Default value: 5
	ItemDuration *uint64 `json:"ItemDuration,omitnil,omitempty" name:"ItemDuration"`

	// Whether to remove watermarks.
	// If you pass in `true`, the original stream will be recorded.
	// Default value: `false`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// The transcoding template IDs.
	// This API works only if `RemoveWatermark` is `false`.
	TranscodeTemplateIds []*int64 `json:"TranscodeTemplateIds,omitnil,omitempty" name:"TranscodeTemplateIds"`

	// The region.
	// `Mainland`: The Chinese mainland.
	// `Overseas`: Outside the Chinese mainland.
	// Default value: `Mainland`.
	Area *string `json:"Area,omitnil,omitempty" name:"Area"`
}

func (r *ModifyLiveTimeShiftTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveTimeShiftTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	delete(f, "TemplateName")
	delete(f, "Description")
	delete(f, "Duration")
	delete(f, "ItemDuration")
	delete(f, "RemoveWatermark")
	delete(f, "TranscodeTemplateIds")
	delete(f, "Area")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLiveTimeShiftTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveTimeShiftTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLiveTimeShiftTemplateResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLiveTimeShiftTemplateResponseParams `json:"Response"`
}

func (r *ModifyLiveTimeShiftTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveTimeShiftTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveTranscodeTemplateRequestParams struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Video codec. Valid values: h264, h265, origin (default)
	// 
	// origin: original codec as the output codec
	Vcodec *string `json:"Vcodec,omitnil,omitempty" name:"Vcodec"`

	// Audio codec. Defaut value: aac.
	// Note: this parameter is unsupported now.
	Acodec *string `json:"Acodec,omitnil,omitempty" name:"Acodec"`

	// Audio bitrate. Default value: 0.
	// Value range: 0-500.
	AudioBitrate *int64 `json:"AudioBitrate,omitnil,omitempty" name:"AudioBitrate"`

	// Template description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Video bitrate in Kbps. Value range: 100-8000.
	// Note: the transcoding template requires that the bitrate be unique. Therefore, the final saved bitrate may be different from the input bitrate.
	VideoBitrate *int64 `json:"VideoBitrate,omitnil,omitempty" name:"VideoBitrate"`

	// Width in pixels. Value range: 0-3000.
	// It must be a multiple of 2. The original width is 0.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Whether to keep the video. 0: no; 1: yes. Default value: 1.
	NeedVideo *int64 `json:"NeedVideo,omitnil,omitempty" name:"NeedVideo"`

	// Whether to keep the audio. 0: no; 1: yes. Default value: 1.
	NeedAudio *int64 `json:"NeedAudio,omitnil,omitempty" name:"NeedAudio"`

	// Height in pixels. Value range: 0-3000.
	// It must be a multiple of 2. The original height is 0.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Frame rate in fps. Default value: 0.
	// Value range: 0-60
	Fps *int64 `json:"Fps,omitnil,omitempty" name:"Fps"`

	// Keyframe interval in seconds.
	// Value range: 2-6
	Gop *int64 `json:"Gop,omitnil,omitempty" name:"Gop"`

	// Rotation angle. Default value: 0.
	// Valid values: 0, 90, 180, 270
	Rotate *int64 `json:"Rotate,omitnil,omitempty" name:"Rotate"`

	// Encoding quality:
	// baseline/main/high.
	Profile *string `json:"Profile,omitnil,omitempty" name:"Profile"`

	// Whether to use the original bitrate when the set bitrate is larger than the original bitrate.
	// 0: no, 1: yes
	// Default value: 0.
	BitrateToOrig *int64 `json:"BitrateToOrig,omitnil,omitempty" name:"BitrateToOrig"`

	// Whether to use the original height when the set height is higher than the original height.
	// 0: no, 1: yes
	// Default value: 0.
	HeightToOrig *int64 `json:"HeightToOrig,omitnil,omitempty" name:"HeightToOrig"`

	// Whether to use the original frame rate when the set frame rate is larger than the original frame rate.
	// 0: no, 1: yes
	// Default value: 0.
	FpsToOrig *int64 `json:"FpsToOrig,omitnil,omitempty" name:"FpsToOrig"`

	// Bitrate compression ratio of top speed codec video.
	// Target bitrate of top speed code = VideoBitrate * (1-AdaptBitratePercent)
	// 
	// Value range: 0.0-0.5.
	AdaptBitratePercent *float64 `json:"AdaptBitratePercent,omitnil,omitempty" name:"AdaptBitratePercent"`

	// Whether to use the short side as the video height. 0: no, 1: yes. Default value: 0.
	ShortEdgeAsHeight *int64 `json:"ShortEdgeAsHeight,omitnil,omitempty" name:"ShortEdgeAsHeight"`

	// The DRM encryption type. Valid values: fairplay, normalaes, widevine.
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMType *string `json:"DRMType,omitnil,omitempty" name:"DRMType"`

	// The tracks to encrypt. Valid values: AUDIO, SD, HD, UHD1, UHD2. You can choose only one video track (SD, HD, UHD1, or UHD2).
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMTracks *string `json:"DRMTracks,omitnil,omitempty" name:"DRMTracks"`
}

type ModifyLiveTranscodeTemplateRequest struct {
	*tchttp.BaseRequest
	
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Video codec. Valid values: h264, h265, origin (default)
	// 
	// origin: original codec as the output codec
	Vcodec *string `json:"Vcodec,omitnil,omitempty" name:"Vcodec"`

	// Audio codec. Defaut value: aac.
	// Note: this parameter is unsupported now.
	Acodec *string `json:"Acodec,omitnil,omitempty" name:"Acodec"`

	// Audio bitrate. Default value: 0.
	// Value range: 0-500.
	AudioBitrate *int64 `json:"AudioBitrate,omitnil,omitempty" name:"AudioBitrate"`

	// Template description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Video bitrate in Kbps. Value range: 100-8000.
	// Note: the transcoding template requires that the bitrate be unique. Therefore, the final saved bitrate may be different from the input bitrate.
	VideoBitrate *int64 `json:"VideoBitrate,omitnil,omitempty" name:"VideoBitrate"`

	// Width in pixels. Value range: 0-3000.
	// It must be a multiple of 2. The original width is 0.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Whether to keep the video. 0: no; 1: yes. Default value: 1.
	NeedVideo *int64 `json:"NeedVideo,omitnil,omitempty" name:"NeedVideo"`

	// Whether to keep the audio. 0: no; 1: yes. Default value: 1.
	NeedAudio *int64 `json:"NeedAudio,omitnil,omitempty" name:"NeedAudio"`

	// Height in pixels. Value range: 0-3000.
	// It must be a multiple of 2. The original height is 0.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Frame rate in fps. Default value: 0.
	// Value range: 0-60
	Fps *int64 `json:"Fps,omitnil,omitempty" name:"Fps"`

	// Keyframe interval in seconds.
	// Value range: 2-6
	Gop *int64 `json:"Gop,omitnil,omitempty" name:"Gop"`

	// Rotation angle. Default value: 0.
	// Valid values: 0, 90, 180, 270
	Rotate *int64 `json:"Rotate,omitnil,omitempty" name:"Rotate"`

	// Encoding quality:
	// baseline/main/high.
	Profile *string `json:"Profile,omitnil,omitempty" name:"Profile"`

	// Whether to use the original bitrate when the set bitrate is larger than the original bitrate.
	// 0: no, 1: yes
	// Default value: 0.
	BitrateToOrig *int64 `json:"BitrateToOrig,omitnil,omitempty" name:"BitrateToOrig"`

	// Whether to use the original height when the set height is higher than the original height.
	// 0: no, 1: yes
	// Default value: 0.
	HeightToOrig *int64 `json:"HeightToOrig,omitnil,omitempty" name:"HeightToOrig"`

	// Whether to use the original frame rate when the set frame rate is larger than the original frame rate.
	// 0: no, 1: yes
	// Default value: 0.
	FpsToOrig *int64 `json:"FpsToOrig,omitnil,omitempty" name:"FpsToOrig"`

	// Bitrate compression ratio of top speed codec video.
	// Target bitrate of top speed code = VideoBitrate * (1-AdaptBitratePercent)
	// 
	// Value range: 0.0-0.5.
	AdaptBitratePercent *float64 `json:"AdaptBitratePercent,omitnil,omitempty" name:"AdaptBitratePercent"`

	// Whether to use the short side as the video height. 0: no, 1: yes. Default value: 0.
	ShortEdgeAsHeight *int64 `json:"ShortEdgeAsHeight,omitnil,omitempty" name:"ShortEdgeAsHeight"`

	// The DRM encryption type. Valid values: fairplay, normalaes, widevine.
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMType *string `json:"DRMType,omitnil,omitempty" name:"DRMType"`

	// The tracks to encrypt. Valid values: AUDIO, SD, HD, UHD1, UHD2. You can choose only one video track (SD, HD, UHD1, or UHD2).
	// If you do not pass this parameter or pass in an empty string, the existing configuration will be reset.
	DRMTracks *string `json:"DRMTracks,omitnil,omitempty" name:"DRMTracks"`
}

func (r *ModifyLiveTranscodeTemplateRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveTranscodeTemplateRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TemplateId")
	delete(f, "Vcodec")
	delete(f, "Acodec")
	delete(f, "AudioBitrate")
	delete(f, "Description")
	delete(f, "VideoBitrate")
	delete(f, "Width")
	delete(f, "NeedVideo")
	delete(f, "NeedAudio")
	delete(f, "Height")
	delete(f, "Fps")
	delete(f, "Gop")
	delete(f, "Rotate")
	delete(f, "Profile")
	delete(f, "BitrateToOrig")
	delete(f, "HeightToOrig")
	delete(f, "FpsToOrig")
	delete(f, "AdaptBitratePercent")
	delete(f, "ShortEdgeAsHeight")
	delete(f, "DRMType")
	delete(f, "DRMTracks")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ModifyLiveTranscodeTemplateRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ModifyLiveTranscodeTemplateResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ModifyLiveTranscodeTemplateResponse struct {
	*tchttp.BaseResponse
	Response *ModifyLiveTranscodeTemplateResponseParams `json:"Response"`
}

func (r *ModifyLiveTranscodeTemplateResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ModifyLiveTranscodeTemplateResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type MonitorStreamPlayInfo struct {
	// The playback domain.
	PlayDomain *string `json:"PlayDomain,omitnil,omitempty" name:"PlayDomain"`

	// The stream ID.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The playback bitrate. `0` indicates the original bitrate.
	Rate *uint64 `json:"Rate,omitnil,omitempty" name:"Rate"`

	// The playback protocol. Valid values: `Unknown`, `Flv`, `Hls`, `Rtmp`, `Huyap2p`.
	Protocol *string `json:"Protocol,omitnil,omitempty" name:"Protocol"`

	// The bandwidth (Mbps).
	Bandwidth *float64 `json:"Bandwidth,omitnil,omitempty" name:"Bandwidth"`

	// The number of online users, which is represented by the number of TCP connections (data collected every minute).
	Online *uint64 `json:"Online,omitnil,omitempty" name:"Online"`

	// The number of requests.
	Request *uint64 `json:"Request,omitnil,omitempty" name:"Request"`
}

type PlayAuthKeyInfo struct {
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable:
	// 0: disable.
	// 1: enable.
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// Authentication key.
	AuthKey *string `json:"AuthKey,omitnil,omitempty" name:"AuthKey"`

	// Validity period in seconds.
	AuthDelta *uint64 `json:"AuthDelta,omitnil,omitempty" name:"AuthDelta"`

	// Authentication `BackKey`.
	AuthBackKey *string `json:"AuthBackKey,omitnil,omitempty" name:"AuthBackKey"`
}

type PlayCodeTotalInfo struct {
	// HTTP code. Valid values:
	// 400, 403, 404, 500, 502, 503, 504.
	Code *string `json:"Code,omitnil,omitempty" name:"Code"`

	// Total occurrences.
	Num *uint64 `json:"Num,omitnil,omitempty" name:"Num"`
}

type PlayDataInfoByStream struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Total traffic in MB.
	TotalFlux *float64 `json:"TotalFlux,omitnil,omitempty" name:"TotalFlux"`
}

type PlayStatInfo struct {
	// Data point in time.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Value of bandwidth/traffic/number of requests/number of concurrent connections/download speed. If there is no data returned, the value is 0.
	// Note: this field may return null, indicating that no valid values can be obtained.
	Value *float64 `json:"Value,omitnil,omitempty" name:"Value"`
}

type PlaySumStatInfo struct {
	// Domain name or stream ID.
	Name *string `json:"Name,omitnil,omitempty" name:"Name"`

	// Average download speed,
	// In MB/s.
	// Calculation formula: average download speed per minute.
	AvgFluxPerSecond *float64 `json:"AvgFluxPerSecond,omitnil,omitempty" name:"AvgFluxPerSecond"`

	// Total traffic in MB.
	TotalFlux *float64 `json:"TotalFlux,omitnil,omitempty" name:"TotalFlux"`

	// Total number of requests.
	TotalRequest *uint64 `json:"TotalRequest,omitnil,omitempty" name:"TotalRequest"`
}

type ProIspPlayCodeDataInfo struct {
	// Country or region.
	CountryAreaName *string `json:"CountryAreaName,omitnil,omitempty" name:"CountryAreaName"`

	// District.
	ProvinceName *string `json:"ProvinceName,omitnil,omitempty" name:"ProvinceName"`

	// ISP.
	IspName *string `json:"IspName,omitnil,omitempty" name:"IspName"`

	// Occurrences of 2xx error codes.
	Code2xx *uint64 `json:"Code2xx,omitnil,omitempty" name:"Code2xx"`

	// Occurrences of 3xx error codes.
	Code3xx *uint64 `json:"Code3xx,omitnil,omitempty" name:"Code3xx"`

	// Occurrences of 4xx error codes.
	Code4xx *uint64 `json:"Code4xx,omitnil,omitempty" name:"Code4xx"`

	// Occurrences of 5xx error codes.
	Code5xx *uint64 `json:"Code5xx,omitnil,omitempty" name:"Code5xx"`
}

type PublishTime struct {
	// Push time.
	// In UTC format, such as 2018-06-29T19:00:00Z.
	PublishTime *string `json:"PublishTime,omitnil,omitempty" name:"PublishTime"`
}

type PullPushWatermarkInfo struct {
	// The watermark image URL.
	// Characters not allowed:
	// ;(){}$>`#"'|
	PictureUrl *string `json:"PictureUrl,omitnil,omitempty" name:"PictureUrl"`

	// The horizontal offset (%) of the watermark. The default value is 0.
	XPosition *int64 `json:"XPosition,omitnil,omitempty" name:"XPosition"`

	// The vertical offset (%) of the watermark. The default value is 0.
	YPosition *int64 `json:"YPosition,omitnil,omitempty" name:"YPosition"`

	// The watermark width as a percentage of the video width. To avoid distorted images, we recommend you specify only the width or height so that the other side can be scaled proportionally. By default, the original width of the watermark image is used.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// The watermark height as a percentage of the video height. To avoid distorted images, we recommend you specify only the width or height so that the other side can be scaled proportionally. By default, the original height of the watermark image is used.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// The origin. The default value is 0.
	// 0: Top left corner
	// 1: Top right corner
	// 2: Bottom right corner
	// 3: Bottom left corner
	Location *int64 `json:"Location,omitnil,omitempty" name:"Location"`
}

type PullStreamTaskInfo struct {
	// The task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// The source type. Valid values:
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// PullPicPushLive: Images
	SourceType *string `json:"SourceType,omitnil,omitempty" name:"SourceType"`

	// The source URL(s).
	// If `SourceType` is `PullLiveToLive`, there can be only one source URL.
	// If `SourceType` is `PullVodToLive`, there can be at most 10 source URLs.
	SourceUrls []*string `json:"SourceUrls,omitnil,omitempty" name:"SourceUrls"`

	// The push domain name.
	// The pulled stream is pushed to this domain.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// The application to push to.
	// The pulled stream is pushed to this application.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	// The pulled stream is pushed under this name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The push parameter.
	// A custom push parameter.
	PushArgs *string `json:"PushArgs,omitnil,omitempty" name:"PushArgs"`

	// The start time.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time. Notes:
	// 1. The end time must be later than the start time.
	// 2. The end time and start time must be later than the current time.
	// 3. The end time and start time must be less than seven days apart.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The region where the task was created.
	// `ap-beijing`: North China (Beijing)
	// `ap-shanghai`: East China (Shanghai)
	// `ap-guangzhou`: South China (Guangzhou)
	// `ap-mumbai`: India
	// `ap-hongkong`: Hong Kong
	// `eu-frankfurt`: Germany
	// `ap-seoul`: Korea
	// `ap-bangkok`: Thailand
	// `ap-singapore`: Singapore
	// `na-siliconvalley`: Western US
	// `na-ashburn`: Eastern US
	// `ap-tokyo`: Japan
	Region *string `json:"Region,omitnil,omitempty" name:"Region"`

	// The number of times to loop video files.
	// -1: Loop indefinitely
	// 0: Do not loop
	// > 0: The number of loop times. A task will end either when the videos are looped for the specified number of times or at the specified task end time, whichever is earlier.
	// This parameter is valid only if the source is video files.
	VodLoopTimes *int64 `json:"VodLoopTimes,omitnil,omitempty" name:"VodLoopTimes"`

	// The behavior after the source video files (`SourceUrls`) are changed.
	// ImmediateNewSource: Play the new videos immediately
	// ContinueBreakPoint: Finish the current video first and then pull from the new source.
	// 
	// This parameter is valid only if the source is video files.
	VodRefreshType *string `json:"VodRefreshType,omitnil,omitempty" name:"VodRefreshType"`

	// The task creation time.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// The last updated time.
	// It must be in UTC format.
	// Example: 2019-01-08T10:00:00Z.
	// Note: Beijing time is 8 hours ahead of UTC. The [ISO 8601 format](https://intl.cloud.tencent.com/document/product/266/11732#iso-date-format) is used.
	UpdateTime *string `json:"UpdateTime,omitnil,omitempty" name:"UpdateTime"`

	// The task creator.
	CreateBy *string `json:"CreateBy,omitnil,omitempty" name:"CreateBy"`

	// The operator of the last update.
	UpdateBy *string `json:"UpdateBy,omitnil,omitempty" name:"UpdateBy"`

	// The callback URL.
	CallbackUrl *string `json:"CallbackUrl,omitnil,omitempty" name:"CallbackUrl"`

	// The events to listen for.
	// TaskStart: Callback for starting a task
	// TaskExit: Callback for ending a task
	// VodSourceFileStart: Callback for starting to pull from video files
	// VodSourceFileFinish: Callback for stopping pulling from video files
	// ResetTaskConfig: Callback for modifying a task
	CallbackEvents []*string `json:"CallbackEvents,omitnil,omitempty" name:"CallbackEvents"`

	// Note: This parameter is not returned currently.
	// The information of the last callback.
	CallbackInfo *string `json:"CallbackInfo,omitnil,omitempty" name:"CallbackInfo"`

	// Note: This parameter is not returned currently.
	// Error message.
	ErrorInfo *string `json:"ErrorInfo,omitnil,omitempty" name:"ErrorInfo"`

	// The task status.
	// enable: Enabled
	// pause: Paused
	Status *string `json:"Status,omitnil,omitempty" name:"Status"`

	// Note: This parameter is returned only if one task is queried.
	// The latest pull information.
	// The information includes the source URL, offset, and report time.
	RecentPullInfo *RecentPullInfo `json:"RecentPullInfo,omitnil,omitempty" name:"RecentPullInfo"`

	// The remarks for the task.
	Comment *string `json:"Comment,omitnil,omitempty" name:"Comment"`

	// The backup source type. Valid values:
	// PullLivePushLive: Live streaming
	// PullVodPushLive: Video files
	// Note: This field may return null, indicating that no valid values can be obtained.
	BackupSourceType *string `json:"BackupSourceType,omitnil,omitempty" name:"BackupSourceType"`

	// The URL of the backup source.
	// Note: This field may return null, indicating that no valid values can be obtained.
	BackupSourceUrl *string `json:"BackupSourceUrl,omitnil,omitempty" name:"BackupSourceUrl"`

	// The information of watermarks to add.
	// Note: This field may return null, indicating that no valid values can be obtained.
	WatermarkList []*PullPushWatermarkInfo `json:"WatermarkList,omitnil,omitempty" name:"WatermarkList"`

	// Whether to use local mode when the source type is video files. The default is `0`.
	// 0: Do not use local mode
	// 1: Use local mode
	// Note: This field may return null, indicating that no valid values can be obtained.
	VodLocalMode *int64 `json:"VodLocalMode,omitnil,omitempty" name:"VodLocalMode"`

	//  Recording template ID.
	RecordTemplateId *string `json:"RecordTemplateId,omitnil,omitempty" name:"RecordTemplateId"`

	// Newly added streaming address. Used for the scenario of pushing two streams with a single task.
	BackupToUrl *string `json:"BackupToUrl,omitnil,omitempty" name:"BackupToUrl"`
}

type PushAuthKeyInfo struct {
	// Domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable. 0: disabled; 1: enabled.
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// Master authentication key.
	MasterAuthKey *string `json:"MasterAuthKey,omitnil,omitempty" name:"MasterAuthKey"`

	// Standby authentication key.
	BackupAuthKey *string `json:"BackupAuthKey,omitnil,omitempty" name:"BackupAuthKey"`

	// Validity period in seconds.
	AuthDelta *uint64 `json:"AuthDelta,omitnil,omitempty" name:"AuthDelta"`
}

type PushDataInfo struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push client IP.
	ClientIp *string `json:"ClientIp,omitnil,omitempty" name:"ClientIp"`

	// IP of the server that receives the stream.
	ServerIp *string `json:"ServerIp,omitnil,omitempty" name:"ServerIp"`

	// Pushed video frame rate in Hz.
	VideoFps *uint64 `json:"VideoFps,omitnil,omitempty" name:"VideoFps"`

	// Video bitrate (bps) for publishing
	VideoSpeed *uint64 `json:"VideoSpeed,omitnil,omitempty" name:"VideoSpeed"`

	// Pushed audio frame rate in Hz.
	AudioFps *uint64 `json:"AudioFps,omitnil,omitempty" name:"AudioFps"`

	// Audio bitrate (bps) for publishing
	AudioSpeed *uint64 `json:"AudioSpeed,omitnil,omitempty" name:"AudioSpeed"`

	// Push domain name.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// Push start time.
	BeginPushTime *string `json:"BeginPushTime,omitnil,omitempty" name:"BeginPushTime"`

	// Audio codec,
	// Example: AAC.
	Acodec *string `json:"Acodec,omitnil,omitempty" name:"Acodec"`

	// Video codec,
	// Example: H.264.
	Vcodec *string `json:"Vcodec,omitnil,omitempty" name:"Vcodec"`

	// Resolution.
	Resolution *string `json:"Resolution,omitnil,omitempty" name:"Resolution"`

	// Sample rate.
	AsampleRate *uint64 `json:"AsampleRate,omitnil,omitempty" name:"AsampleRate"`

	// Audio bitrate (bps) in metadata
	MetaAudioSpeed *uint64 `json:"MetaAudioSpeed,omitnil,omitempty" name:"MetaAudioSpeed"`

	// Video bitrate (bps) in metadata
	MetaVideoSpeed *uint64 `json:"MetaVideoSpeed,omitnil,omitempty" name:"MetaVideoSpeed"`

	// Frame rate in `metadata`.
	MetaFps *uint64 `json:"MetaFps,omitnil,omitempty" name:"MetaFps"`
}

type PushQualityData struct {
	// The time of the data in the format of “%Y-%m-%d %H:%M:%S.%ms” (accurate to the millisecond).
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// The push domain.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// The push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The IP address of the push client.
	ClientIp *string `json:"ClientIp,omitnil,omitempty" name:"ClientIp"`

	// The push start time in the format of “%Y-%m-%d %H:%M:%S.%ms” (accurate to the millisecond).
	BeginPushTime *string `json:"BeginPushTime,omitnil,omitempty" name:"BeginPushTime"`

	// The resolution.
	Resolution *string `json:"Resolution,omitnil,omitempty" name:"Resolution"`

	// The video codec.
	VCodec *string `json:"VCodec,omitnil,omitempty" name:"VCodec"`

	// The audio codec.
	ACodec *string `json:"ACodec,omitnil,omitempty" name:"ACodec"`

	// The push sequence number, which uniquely identifies a push.
	Sequence *string `json:"Sequence,omitnil,omitempty" name:"Sequence"`

	// The video frame rate.
	VideoFps *uint64 `json:"VideoFps,omitnil,omitempty" name:"VideoFps"`

	// The video bitrate (bps).
	VideoRate *uint64 `json:"VideoRate,omitnil,omitempty" name:"VideoRate"`

	// The audio frame rate.
	AudioFps *uint64 `json:"AudioFps,omitnil,omitempty" name:"AudioFps"`

	// The audio bitrate (bps).
	AudioRate *uint64 `json:"AudioRate,omitnil,omitempty" name:"AudioRate"`

	// The local elapsed time (milliseconds). The greater the difference between the local elapsed time and audio/video elapsed time, the poorer the push quality and the more severe the upstream lag.
	LocalTs *uint64 `json:"LocalTs,omitnil,omitempty" name:"LocalTs"`

	// The video elapsed time (milliseconds).
	VideoTs *uint64 `json:"VideoTs,omitnil,omitempty" name:"VideoTs"`

	// The audio elapsed time (milliseconds).
	AudioTs *uint64 `json:"AudioTs,omitnil,omitempty" name:"AudioTs"`

	// The video bitrate (Kbps) in the metadata.
	MetaVideoRate *uint64 `json:"MetaVideoRate,omitnil,omitempty" name:"MetaVideoRate"`

	// The audio bitrate (Kbps) in the metadata.
	MetaAudioRate *uint64 `json:"MetaAudioRate,omitnil,omitempty" name:"MetaAudioRate"`

	// The frame rate in the metadata.
	MateFps *uint64 `json:"MateFps,omitnil,omitempty" name:"MateFps"`

	// The push parameter.
	StreamParam *string `json:"StreamParam,omitnil,omitempty" name:"StreamParam"`

	// The bandwidth (Mbps).
	Bandwidth *float64 `json:"Bandwidth,omitnil,omitempty" name:"Bandwidth"`

	// The traffic (MB).
	Flux *float64 `json:"Flux,omitnil,omitempty" name:"Flux"`

	// The IP address of the push client.
	// Note: This field may return null, indicating that no valid values can be obtained.
	ServerIp *string `json:"ServerIp,omitnil,omitempty" name:"ServerIp"`
}

type RecentPullInfo struct {
	// The URL of the file currently pulled.
	FileUrl *string `json:"FileUrl,omitnil,omitempty" name:"FileUrl"`

	// The offset of the file currently pulled.
	OffsetTime *uint64 `json:"OffsetTime,omitnil,omitempty" name:"OffsetTime"`

	// The time when the offset is reported, in UTC format.
	// Example: 2020-07-23T03:20:39Z
	// Note: Beijing time is 8 hours ahead of UTC.
	ReportTime *string `json:"ReportTime,omitnil,omitempty" name:"ReportTime"`

	// The number of times looped.
	LoopedTimes *int64 `json:"LoopedTimes,omitnil,omitempty" name:"LoopedTimes"`
}

type RecordParam struct {
	// Max recording time per file
	// Default value: `1800` (seconds)
	// Value range: 30-7200
	// This parameter is invalid for HLS. Only one HLS file will be generated from push start to push end.
	RecordInterval *int64 `json:"RecordInterval,omitnil,omitempty" name:"RecordInterval"`

	// Storage duration of the recording file
	// Value range: 0-129600000 seconds (0-1500 days)
	// `0`: permanent
	StorageTime *int64 `json:"StorageTime,omitnil,omitempty" name:"StorageTime"`

	// Whether to enable recording in the current format. Default value: 0. 0: no, 1: yes.
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// VOD subapplication ID.
	VodSubAppId *int64 `json:"VodSubAppId,omitnil,omitempty" name:"VodSubAppId"`

	// Recording filename.
	// Supported special placeholders include:
	// {StreamID}: stream ID
	// {StartYear}: start time - year
	// {StartMonth}: start time - month
	// {StartDay}: start time - day
	// {StartHour}: start time - hour
	// {StartMinute}: start time - minute
	// {StartSecond}: start time - second
	// {StartMillisecond}: start time - millisecond
	// {EndYear}: end time - year
	// {EndMonth}: end time - month
	// {EndDay}: end time - day
	// {EndHour}: end time - hour
	// {EndMinute}: end time - minute
	// {EndSecond}: end time - second
	// {EndMillisecond}: end time - millisecond
	// 
	// If this parameter is not set, the recording filename will be `{StreamID}_{StartYear}-{StartMonth}-{StartDay}-{StartHour}-{StartMinute}-{StartSecond}_{EndYear}-{EndMonth}-{EndDay}-{EndHour}-{EndMinute}-{EndSecond}` by default
	VodFileName *string `json:"VodFileName,omitnil,omitempty" name:"VodFileName"`

	// Task flow
	// Note: this field may return `null`, indicating that no valid value is obtained.
	Procedure *string `json:"Procedure,omitnil,omitempty" name:"Procedure"`

	// Video storage class. Valid values:
	// `normal`: STANDARD
	// `cold`: STANDARD_IA
	// Note: this field may return `null`, indicating that no valid value is obtained.
	StorageMode *string `json:"StorageMode,omitnil,omitempty" name:"StorageMode"`

	// VOD subapplication category
	// Note: this field may return `null`, indicating that no valid value is obtained.
	ClassId *int64 `json:"ClassId,omitnil,omitempty" name:"ClassId"`
}

type RecordTask struct {
	// Recording task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The start time of the recording task in Unix timestamp. 
	StartTime *uint64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The end time of the recording task in Unix timestamp. 
	EndTime *uint64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Recording template ID.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The StopRecordTask API call stops the task at the Unix timestamp. A value of 0 indicates that the API has not been called to stop the task.
	Stopped *uint64 `json:"Stopped,omitnil,omitempty" name:"Stopped"`
}

type RecordTemplateInfo struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Message description
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// FLV recording parameter.
	FlvParam *RecordParam `json:"FlvParam,omitnil,omitempty" name:"FlvParam"`

	// HLS recording parameter.
	HlsParam *RecordParam `json:"HlsParam,omitnil,omitempty" name:"HlsParam"`

	// MP4 recording parameter.
	Mp4Param *RecordParam `json:"Mp4Param,omitnil,omitempty" name:"Mp4Param"`

	// AAC recording parameter.
	AacParam *RecordParam `json:"AacParam,omitnil,omitempty" name:"AacParam"`

	// 0: LVB,
	// 1: LCB.
	IsDelayLive *int64 `json:"IsDelayLive,omitnil,omitempty" name:"IsDelayLive"`

	// A special parameter for HLS recording.
	HlsSpecialParam *HlsSpecialParam `json:"HlsSpecialParam,omitnil,omitempty" name:"HlsSpecialParam"`

	// MP3 recording parameter.
	Mp3Param *RecordParam `json:"Mp3Param,omitnil,omitempty" name:"Mp3Param"`

	// Whether the watermark is removed.
	// Note: This field may return `null`, indicating that no valid value was found.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// A special parameter for FLV recording.
	// Note: This field may return `null`, indicating that no valid value can be obtained.
	FlvSpecialParam *FlvSpecialParam `json:"FlvSpecialParam,omitnil,omitempty" name:"FlvSpecialParam"`
}

type RefererAuthConfig struct {
	// Domain name
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Whether to enable referer. Valid values: `0` (no), `1` (yes)
	Enable *int64 `json:"Enable,omitnil,omitempty" name:"Enable"`

	// List type. Valid values: `0` (blocklist), `1` (allowlist)
	Type *int64 `json:"Type,omitnil,omitempty" name:"Type"`

	// Whether to allow empty referer. Valid values: `0` (no), `1` (yes)
	AllowEmpty *int64 `json:"AllowEmpty,omitnil,omitempty" name:"AllowEmpty"`

	// Referer list. Separate items in it with semicolons (;).
	Rules *string `json:"Rules,omitnil,omitempty" name:"Rules"`
}

// Predefined struct for user
type RestartLivePullStreamTaskRequestParams struct {
	// Task Id.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// task operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`
}

type RestartLivePullStreamTaskRequest struct {
	*tchttp.BaseRequest
	
	// Task Id.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`

	// task operator.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`
}

func (r *RestartLivePullStreamTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *RestartLivePullStreamTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TaskId")
	delete(f, "Operator")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "RestartLivePullStreamTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type RestartLivePullStreamTaskResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type RestartLivePullStreamTaskResponse struct {
	*tchttp.BaseResponse
	Response *RestartLivePullStreamTaskResponseParams `json:"Response"`
}

func (r *RestartLivePullStreamTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *RestartLivePullStreamTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ResumeDelayLiveStreamRequestParams struct {
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type ResumeDelayLiveStreamRequest struct {
	*tchttp.BaseRequest
	
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *ResumeDelayLiveStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ResumeDelayLiveStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "AppName")
	delete(f, "DomainName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ResumeDelayLiveStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ResumeDelayLiveStreamResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ResumeDelayLiveStreamResponse struct {
	*tchttp.BaseResponse
	Response *ResumeDelayLiveStreamResponseParams `json:"Response"`
}

func (r *ResumeDelayLiveStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ResumeDelayLiveStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ResumeLiveStreamRequestParams struct {
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type ResumeLiveStreamRequest struct {
	*tchttp.BaseRequest
	
	// Push path, which is the same as the AppName in push and playback addresses and is "live" by default.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

func (r *ResumeLiveStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ResumeLiveStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "AppName")
	delete(f, "DomainName")
	delete(f, "StreamName")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "ResumeLiveStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type ResumeLiveStreamResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type ResumeLiveStreamResponse struct {
	*tchttp.BaseResponse
	Response *ResumeLiveStreamResponseParams `json:"Response"`
}

func (r *ResumeLiveStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *ResumeLiveStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type RuleInfo struct {
	// The rule creation time.
	// Note: Beijing time (UTC+8) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// The rule update time.
	// Note: Beijing time (UTC+8) is used.
	UpdateTime *string `json:"UpdateTime,omitnil,omitempty" name:"UpdateTime"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`
}

type SnapshotTemplateInfo struct {
	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Screencapturing interval. Value range: 5-300s.
	SnapshotInterval *int64 `json:"SnapshotInterval,omitnil,omitempty" name:"SnapshotInterval"`

	// Screenshot width. Value range: 0-3000. 
	// 0: original width and fit to the original ratio.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Screenshot height. Value range: 0-2000.
	// 0: original height and fit to the original ratio.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Whether to enable porn detection. 0: no, 1: yes.
	PornFlag *int64 `json:"PornFlag,omitnil,omitempty" name:"PornFlag"`

	// COS application ID.
	CosAppId *int64 `json:"CosAppId,omitnil,omitempty" name:"CosAppId"`

	// COS bucket name.
	CosBucket *string `json:"CosBucket,omitnil,omitempty" name:"CosBucket"`

	// COS region.
	CosRegion *string `json:"CosRegion,omitnil,omitempty" name:"CosRegion"`

	// Template description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// COS bucket folder prefix.
	// Note: this field may return null, indicating that no valid values can be obtained.
	CosPrefix *string `json:"CosPrefix,omitnil,omitempty" name:"CosPrefix"`

	// COS filename.
	// Note: this field may return null, indicating that no valid values can be obtained.
	CosFileName *string `json:"CosFileName,omitnil,omitempty" name:"CosFileName"`
}

// Predefined struct for user
type StartLivePadStreamRequestParams struct {
	// Ensure the streaming path uses the same AppName as the push/play URLs (default: 'live').
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your RTMP push domain.
	PushDomainName *string `json:"PushDomainName,omitnil,omitempty" name:"PushDomainName"`

	// Your stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Operator notes.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`
}

type StartLivePadStreamRequest struct {
	*tchttp.BaseRequest
	
	// Ensure the streaming path uses the same AppName as the push/play URLs (default: 'live').
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Your RTMP push domain.
	PushDomainName *string `json:"PushDomainName,omitnil,omitempty" name:"PushDomainName"`

	// Your stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Operator notes.
	Operator *string `json:"Operator,omitnil,omitempty" name:"Operator"`
}

func (r *StartLivePadStreamRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *StartLivePadStreamRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "AppName")
	delete(f, "PushDomainName")
	delete(f, "StreamName")
	delete(f, "Operator")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "StartLivePadStreamRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type StartLivePadStreamResponseParams struct {
	// The unique request ID, generated by the server, will be returned for every request (if the request fails to reach the server for other reasons, the request will not obtain a RequestId). RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type StartLivePadStreamResponse struct {
	*tchttp.BaseResponse
	Response *StartLivePadStreamResponseParams `json:"Response"`
}

func (r *StartLivePadStreamResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *StartLivePadStreamResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type StopLiveRecordRequestParams struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Task ID returned by the `CreateLiveRecord` API.
	TaskId *int64 `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

type StopLiveRecordRequest struct {
	*tchttp.BaseRequest
	
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Task ID returned by the `CreateLiveRecord` API.
	TaskId *int64 `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

func (r *StopLiveRecordRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *StopLiveRecordRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "StreamName")
	delete(f, "TaskId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "StopLiveRecordRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type StopLiveRecordResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type StopLiveRecordResponse struct {
	*tchttp.BaseResponse
	Response *StopLiveRecordResponseParams `json:"Response"`
}

func (r *StopLiveRecordResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *StopLiveRecordResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type StopRecordTaskRequestParams struct {
	// Recording task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

type StopRecordTaskRequest struct {
	*tchttp.BaseRequest
	
	// Recording task ID.
	TaskId *string `json:"TaskId,omitnil,omitempty" name:"TaskId"`
}

func (r *StopRecordTaskRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *StopRecordTaskRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "TaskId")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "StopRecordTaskRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type StopRecordTaskResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type StopRecordTaskResponse struct {
	*tchttp.BaseResponse
	Response *StopRecordTaskResponseParams `json:"Response"`
}

func (r *StopRecordTaskResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *StopRecordTaskResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type StreamEventInfo struct {
	// Application name.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push start time.
	// In UTC format, such as 2019-01-07T12:00:00Z.
	StreamStartTime *string `json:"StreamStartTime,omitnil,omitempty" name:"StreamStartTime"`

	// Push end time.
	// In UTC format, such as 2019-01-07T15:00:00Z.
	StreamEndTime *string `json:"StreamEndTime,omitnil,omitempty" name:"StreamEndTime"`

	// Stop reason.
	StopReason *string `json:"StopReason,omitnil,omitempty" name:"StopReason"`

	// Push duration in seconds.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// The IP address of the host.
	// If the stream is published from a private network, this parameter will be `-`.
	ClientIp *string `json:"ClientIp,omitnil,omitempty" name:"ClientIp"`

	// Resolution.
	Resolution *string `json:"Resolution,omitnil,omitempty" name:"Resolution"`
}

type StreamName struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Application name.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Push start time.
	// In UTC format, such as 2019-01-07T12:00:00Z.
	StreamStartTime *string `json:"StreamStartTime,omitnil,omitempty" name:"StreamStartTime"`

	// Push end time.
	// In UTC format, such as 2019-01-07T15:00:00Z.
	StreamEndTime *string `json:"StreamEndTime,omitnil,omitempty" name:"StreamEndTime"`

	// Stop reason.
	StopReason *string `json:"StopReason,omitnil,omitempty" name:"StopReason"`

	// Push duration in seconds.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// Host IP.
	ClientIp *string `json:"ClientIp,omitnil,omitempty" name:"ClientIp"`

	// Resolution.
	Resolution *string `json:"Resolution,omitnil,omitempty" name:"Resolution"`
}

type StreamOnlineInfo struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Push time list
	PublishTimeList []*PublishTime `json:"PublishTimeList,omitnil,omitempty" name:"PublishTimeList"`

	// Application name.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// Push domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`
}

type TemplateInfo struct {
	// Codec: h264/h265/origin. Default value: h264.
	// 
	// origin: keep the original codec.
	Vcodec *string `json:"Vcodec,omitnil,omitempty" name:"Vcodec"`

	// Video bitrate. Value range: 0–8,000 Kbps.
	// If the value is 0, the original bitrate will be retained.
	// Note: transcoding templates require a unique bitrate. The final saved bitrate may differ from the input bitrate.
	VideoBitrate *int64 `json:"VideoBitrate,omitnil,omitempty" name:"VideoBitrate"`

	// Audio codec: aac. Default value: aac.
	// Note: This parameter will not take effect for now and will be supported soon.
	Acodec *string `json:"Acodec,omitnil,omitempty" name:"Acodec"`

	// Audio bitrate. Value range: 0–500 Kbps.
	// 0 by default.
	AudioBitrate *int64 `json:"AudioBitrate,omitnil,omitempty" name:"AudioBitrate"`

	// Width. Default value: 0.
	// Value range: [0-3,000].
	// The value must be a multiple of 2. The original width is 0.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Height. Default value: 0.
	// Value range: [0-3,000].
	// The value must be a multiple of 2. The original width is 0.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`

	// Frame rate. Default value: 0.
	// Range: 0-60 Fps.
	Fps *int64 `json:"Fps,omitnil,omitempty" name:"Fps"`

	// Keyframe interval, unit: second.
	// Original interval by default
	// Range: 2-6
	Gop *int64 `json:"Gop,omitnil,omitempty" name:"Gop"`

	// Rotation angle. Default value: 0.
	// Value range: 0, 90, 180, 270
	Rotate *int64 `json:"Rotate,omitnil,omitempty" name:"Rotate"`

	// Encoding quality:
	// baseline/main/high. Default value: baseline.
	Profile *string `json:"Profile,omitnil,omitempty" name:"Profile"`

	// Whether to use the original bitrate when the set bitrate is larger than the original bitrate.
	// 0: no, 1: yes
	// Default value: 0.
	BitrateToOrig *int64 `json:"BitrateToOrig,omitnil,omitempty" name:"BitrateToOrig"`

	// Whether to use the original height when the set height is higher than the original height.
	// 0: no, 1: yes
	// Default value: 0.
	HeightToOrig *int64 `json:"HeightToOrig,omitnil,omitempty" name:"HeightToOrig"`

	// Whether to use the original frame rate when the set frame rate is larger than the original frame rate.
	// 0: no, 1: yes
	// Default value: 0.
	FpsToOrig *int64 `json:"FpsToOrig,omitnil,omitempty" name:"FpsToOrig"`

	// Whether to keep the video. 0: no; 1: yes.
	NeedVideo *int64 `json:"NeedVideo,omitnil,omitempty" name:"NeedVideo"`

	// Whether to keep the audio. 0: no; 1: yes.
	NeedAudio *int64 `json:"NeedAudio,omitnil,omitempty" name:"NeedAudio"`

	// Template ID.
	TemplateId *int64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// Template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// Template description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// Whether it is a top speed codec template. 0: no, 1: yes. Default value: 0.
	AiTransCode *int64 `json:"AiTransCode,omitnil,omitempty" name:"AiTransCode"`

	// Bitrate compression ratio of top speed code video.
	// Target bitrate of top speed code = VideoBitrate * (1-AdaptBitratePercent)
	// 
	// Value range: 0.0-0.5.
	AdaptBitratePercent *float64 `json:"AdaptBitratePercent,omitnil,omitempty" name:"AdaptBitratePercent"`

	// Whether to take the shorter side as height. 0: no, 1: yes. Default value: 0.
	// Note: this field may return `null`, indicating that no valid value is obtained.
	ShortEdgeAsHeight *int64 `json:"ShortEdgeAsHeight,omitnil,omitempty" name:"ShortEdgeAsHeight"`

	// The DRM encryption type. Valid values: fairplay, normalaes, widevine.
	// Note: This field may return null, indicating that no valid values can be obtained.
	DRMType *string `json:"DRMType,omitnil,omitempty" name:"DRMType"`

	// The tracks to encrypt. Valid values: AUDIO, SD, HD, UHD1, UHD2. Separate multiple tracks with “|”. You can choose only one video track (SD, HD, UHD1, or UHD2).
	// Note: This field may return null, indicating that no valid values can be obtained.
	DRMTracks *string `json:"DRMTracks,omitnil,omitempty" name:"DRMTracks"`
}

type TimeShiftBillData struct {
	// The push domain name.
	Domain *string `json:"Domain,omitnil,omitempty" name:"Domain"`

	// The time-shift video length (minutes).
	Duration *float64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// The time-shift days.
	StoragePeriod *float64 `json:"StoragePeriod,omitnil,omitempty" name:"StoragePeriod"`

	// The time for the data returned. Format: YYYY-MM-DDThh:mm:ssZ.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// The total time-shift duration (minutes).
	TotalDuration *float64 `json:"TotalDuration,omitnil,omitempty" name:"TotalDuration"`
}

type TimeShiftRecord struct {
	// The session ID.
	Sid *string `json:"Sid,omitnil,omitempty" name:"Sid"`

	// The recording start time, which is a Unix timestamp.
	StartTime *int64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The recording end time, which is a Unix timestamp.
	EndTime *int64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`
}

type TimeShiftStreamInfo struct {
	// The group the push domain belongs to.
	// Note: This field may return null, indicating that no valid values can be obtained.
	DomainGroup *string `json:"DomainGroup,omitnil,omitempty" name:"DomainGroup"`

	// The push domain.
	Domain *string `json:"Domain,omitnil,omitempty" name:"Domain"`

	// The push path.
	AppName *string `json:"AppName,omitnil,omitempty" name:"AppName"`

	// The stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// The stream start time, which is a Unix timestamp.
	StartTime *int64 `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// The stream end time (for streams that ended before the time of query), which is a Unix timestamp.
	EndTime *int64 `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// The transcoding template ID.
	// Note: This field may return null, indicating that no valid values can be obtained.
	TransCodeId *uint64 `json:"TransCodeId,omitnil,omitempty" name:"TransCodeId"`

	// The stream type. `0`: The original stream; `1`: The watermarked stream; `2`: The transcoded stream.
	StreamType *int64 `json:"StreamType,omitnil,omitempty" name:"StreamType"`

	// The storage duration (seconds) of the recording.
	// Note: This field may return null, indicating that no valid values can be obtained.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`
}

type TimeShiftTemplate struct {
	// The template name.
	TemplateName *string `json:"TemplateName,omitnil,omitempty" name:"TemplateName"`

	// The time shifting duration.
	// Unit: second
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// The segment size.
	// Value range: 3-10.
	// Unit: Second.
	// Default value: 5
	ItemDuration *uint64 `json:"ItemDuration,omitnil,omitempty" name:"ItemDuration"`

	// The template ID.
	TemplateId *uint64 `json:"TemplateId,omitnil,omitempty" name:"TemplateId"`

	// The template description.
	Description *string `json:"Description,omitnil,omitempty" name:"Description"`

	// The region. Valid values:
	// `Mainland`: The Chinese mainland.
	// `Overseas`: Outside the Chinese mainland.
	// Default value: `Mainland`.
	Area *string `json:"Area,omitnil,omitempty" name:"Area"`

	// Whether to remove watermarks.
	// If you pass in `true`, the original stream will be recorded.
	// Default value: `false`.
	RemoveWatermark *bool `json:"RemoveWatermark,omitnil,omitempty" name:"RemoveWatermark"`

	// The transcoding template IDs.
	// This API works only if `RemoveWatermark` is `false`.
	TranscodeTemplateIds []*uint64 `json:"TranscodeTemplateIds,omitnil,omitempty" name:"TranscodeTemplateIds"`
}

type TimeValue struct {
	// UTC time in the format of `yyyy-mm-ddTHH:MM:SSZ`.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Value.
	Num *uint64 `json:"Num,omitnil,omitempty" name:"Num"`
}

type TranscodeDetailInfo struct {
	// Stream name.
	StreamName *string `json:"StreamName,omitnil,omitempty" name:"StreamName"`

	// Start time (Beijing time) in the format of `yyyy-mm-dd HH:MM`.
	StartTime *string `json:"StartTime,omitnil,omitempty" name:"StartTime"`

	// End time (Beijing time) in the format of `yyyy-mm-dd HH:MM`.
	EndTime *string `json:"EndTime,omitnil,omitempty" name:"EndTime"`

	// Transcoding duration in minutes.
	// Note: given the possible interruptions during push, duration here is the sum of actual duration of transcoding instead of the interval between the start time and end time.
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// Codec with modules,
	// Example:
	// liveprocessor_H264: LVB transcoding - H264,
	// liveprocessor_H265: LVB transcoding - H265,
	// topspeed_H264: top speed codec - H264,
	// topspeed_H265: top speed codec - H265.
	ModuleCodec *string `json:"ModuleCodec,omitnil,omitempty" name:"ModuleCodec"`

	// Bitrate.
	Bitrate *uint64 `json:"Bitrate,omitnil,omitempty" name:"Bitrate"`

	// The task type. Valid values: Transcode, MixStream, WaterMark, Webrtc.
	Type *string `json:"Type,omitnil,omitempty" name:"Type"`

	// Push domain name.
	PushDomain *string `json:"PushDomain,omitnil,omitempty" name:"PushDomain"`

	// Resolution.
	Resolution *string `json:"Resolution,omitnil,omitempty" name:"Resolution"`

	// The region. Valid values:
	// `Mainland`: Inside the Chinese mainland.
	// `Overseas`: Outside the Chinese mainland.
	MainlandOrOversea *string `json:"MainlandOrOversea,omitnil,omitempty" name:"MainlandOrOversea"`
}

type TranscodeTaskNum struct {
	// The time of query.
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// The bitrate.
	CodeRate *uint64 `json:"CodeRate,omitnil,omitempty" name:"CodeRate"`

	// The number of tasks.
	Num *uint64 `json:"Num,omitnil,omitempty" name:"Num"`
}

type TranscodeTotalInfo struct {
	// Usage time (Beijing time)
	// Example: 2019-03-01 00:00:00
	Time *string `json:"Time,omitnil,omitempty" name:"Time"`

	// Transcoding duration in minutes
	Duration *uint64 `json:"Duration,omitnil,omitempty" name:"Duration"`

	// Codec, with modules
	// Examples:
	// `liveprocessor_H264`: live transcoding-H264
	// `liveprocessor_H265`: live transcoding-H265
	// `topspeed_H264`: top speed codec-H264
	// `topspeed_H265`: top speed codec-H265
	ModuleCodec *string `json:"ModuleCodec,omitnil,omitempty" name:"ModuleCodec"`

	// Resolution
	// Example: 540*480
	Resolution *string `json:"Resolution,omitnil,omitempty" name:"Resolution"`
}

// Predefined struct for user
type UnBindLiveDomainCertRequestParams struct {
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Valid values:
	// `gray`: unbind the canary certificate
	// `formal` (default): unbind the formal certificate
	// 
	// `formal` will be used if no value is passed in
	Type *string `json:"Type,omitnil,omitempty" name:"Type"`
}

type UnBindLiveDomainCertRequest struct {
	*tchttp.BaseRequest
	
	// Playback domain name.
	DomainName *string `json:"DomainName,omitnil,omitempty" name:"DomainName"`

	// Valid values:
	// `gray`: unbind the canary certificate
	// `formal` (default): unbind the formal certificate
	// 
	// `formal` will be used if no value is passed in
	Type *string `json:"Type,omitnil,omitempty" name:"Type"`
}

func (r *UnBindLiveDomainCertRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *UnBindLiveDomainCertRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "DomainName")
	delete(f, "Type")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "UnBindLiveDomainCertRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type UnBindLiveDomainCertResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type UnBindLiveDomainCertResponse struct {
	*tchttp.BaseResponse
	Response *UnBindLiveDomainCertResponseParams `json:"Response"`
}

func (r *UnBindLiveDomainCertResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *UnBindLiveDomainCertResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type UpdateLiveWatermarkRequestParams struct {
	// Watermark ID.
	// Get the watermark ID in the returned value of the [AddLiveWatermark](https://intl.cloud.tencent.com/document/product/267/30154?from_cn_redirect=1) API call.
	WatermarkId *int64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`

	// Watermark image URL.
	// Unallowed characters in the URL:
	//  ;(){}$>`#"\'|
	PictureUrl *string `json:"PictureUrl,omitnil,omitempty" name:"PictureUrl"`

	// Display position: X-axis offset in %. Default value: 0.
	XPosition *int64 `json:"XPosition,omitnil,omitempty" name:"XPosition"`

	// Display position: Y-axis offset in %. Default value: 0.
	YPosition *int64 `json:"YPosition,omitnil,omitempty" name:"YPosition"`

	// Watermark name.
	// Up to 16 bytes.
	WatermarkName *string `json:"WatermarkName,omitnil,omitempty" name:"WatermarkName"`

	// Watermark width or its percentage of the live streaming video width. It is recommended to just specify either height or width as the other will be scaled proportionally to avoid distortions. The original width is used by default.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Watermark height or its percentage of the live streaming video width. It is recommended to just specify either height or width as the other will be scaled proportionally to avoid distortions. The original height is used by default.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`
}

type UpdateLiveWatermarkRequest struct {
	*tchttp.BaseRequest
	
	// Watermark ID.
	// Get the watermark ID in the returned value of the [AddLiveWatermark](https://intl.cloud.tencent.com/document/product/267/30154?from_cn_redirect=1) API call.
	WatermarkId *int64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`

	// Watermark image URL.
	// Unallowed characters in the URL:
	//  ;(){}$>`#"\'|
	PictureUrl *string `json:"PictureUrl,omitnil,omitempty" name:"PictureUrl"`

	// Display position: X-axis offset in %. Default value: 0.
	XPosition *int64 `json:"XPosition,omitnil,omitempty" name:"XPosition"`

	// Display position: Y-axis offset in %. Default value: 0.
	YPosition *int64 `json:"YPosition,omitnil,omitempty" name:"YPosition"`

	// Watermark name.
	// Up to 16 bytes.
	WatermarkName *string `json:"WatermarkName,omitnil,omitempty" name:"WatermarkName"`

	// Watermark width or its percentage of the live streaming video width. It is recommended to just specify either height or width as the other will be scaled proportionally to avoid distortions. The original width is used by default.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Watermark height or its percentage of the live streaming video width. It is recommended to just specify either height or width as the other will be scaled proportionally to avoid distortions. The original height is used by default.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`
}

func (r *UpdateLiveWatermarkRequest) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *UpdateLiveWatermarkRequest) FromJsonString(s string) error {
	f := make(map[string]interface{})
	if err := json.Unmarshal([]byte(s), &f); err != nil {
		return err
	}
	delete(f, "WatermarkId")
	delete(f, "PictureUrl")
	delete(f, "XPosition")
	delete(f, "YPosition")
	delete(f, "WatermarkName")
	delete(f, "Width")
	delete(f, "Height")
	if len(f) > 0 {
		return tcerr.NewTencentCloudSDKError("ClientError.BuildRequestError", "UpdateLiveWatermarkRequest has unknown keys!", "")
	}
	return json.Unmarshal([]byte(s), &r)
}

// Predefined struct for user
type UpdateLiveWatermarkResponseParams struct {
	// The unique request ID, which is returned for each request. RequestId is required for locating a problem.
	RequestId *string `json:"RequestId,omitnil,omitempty" name:"RequestId"`
}

type UpdateLiveWatermarkResponse struct {
	*tchttp.BaseResponse
	Response *UpdateLiveWatermarkResponseParams `json:"Response"`
}

func (r *UpdateLiveWatermarkResponse) ToJsonString() string {
    b, _ := json.Marshal(r)
    return string(b)
}

// FromJsonString It is highly **NOT** recommended to use this function
// because it has no param check, nor strict type check
func (r *UpdateLiveWatermarkResponse) FromJsonString(s string) error {
	return json.Unmarshal([]byte(s), &r)
}

type WatermarkInfo struct {
	// Watermark ID.
	WatermarkId *int64 `json:"WatermarkId,omitnil,omitempty" name:"WatermarkId"`

	// Watermark image URL.
	PictureUrl *string `json:"PictureUrl,omitnil,omitempty" name:"PictureUrl"`

	// Display position: X-axis offset.
	XPosition *int64 `json:"XPosition,omitnil,omitempty" name:"XPosition"`

	// Display position: Y-axis offset.
	YPosition *int64 `json:"YPosition,omitnil,omitempty" name:"YPosition"`

	// Watermark name.
	WatermarkName *string `json:"WatermarkName,omitnil,omitempty" name:"WatermarkName"`

	// Current status. 0: not used. 1: in use.
	Status *int64 `json:"Status,omitnil,omitempty" name:"Status"`

	// The time when the watermark was added.
	// Note: Beijing time (UTC+8) is used.
	CreateTime *string `json:"CreateTime,omitnil,omitempty" name:"CreateTime"`

	// Watermark width.
	Width *int64 `json:"Width,omitnil,omitempty" name:"Width"`

	// Watermark height.
	Height *int64 `json:"Height,omitnil,omitempty" name:"Height"`
}